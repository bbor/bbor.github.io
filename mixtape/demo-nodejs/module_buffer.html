<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Buffer</title>
    <script data-main="js/setup" src="js/require.js"></script>
    <link rel="stylesheet" href="fonts/fonts.css" />
    <link rel="stylesheet" href="fonts/fontawesome-all.min.css" />
    <link rel="stylesheet" href="css/layout.css" />
    <link rel="stylesheet" href="toc/themes/default/style.min.css" />
    <link rel="stylesheet" href="css/design.css" />
  </head>
  <body>

  <div id="control-panel">
    <div id="control-strip-m">
      <div id="control-strip-m-find"><div id="m-find"></div></div>
      <div id="control-strip-m-toc"><div id="m-toc"></div></div>
    </div>
    <div id="controls">
      <div id="control-find">
        <div id="control-find-content"><input id="find" class="typeahead" placeholder="Find something..."></div>
      </div>
      <div id="control-toc">
        <div id="control-toc-content"><div id="toc"></div></div>
      </div>
    </div>
  </div>
  <div id="control-strip-w">
    <div id="control-strip-w-find"></div>
    <div id="control-strip-w-toc"></div>
  </div>

  <div id="content">

  
<div class="heading">
<h1>
  <a name="module_buffer" id="module_buffer"></a>
  <div class="permalink"><a href="#module_buffer" class="permalink fas fa-link"></a></div>
  <p>Buffer</p>

</h1>
</div>

<p><p>Prior to the introduction of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html"><code>ECMAScript 2015</code></a> (ES6), the
JavaScript language had no mechanism for reading or manipulating streams
of binary data. The <code>Buffer</code> class was introduced as part of the Node.js
API to make it possible to interact with octet streams in the context of things
like TCP streams and file system operations.</p></p>
<p><p>Now that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> has been added in ES6, the <code>Buffer</code> class implements the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> API in a manner that is more optimized and suitable for Node.js&#39;
use cases.</p></p>
<p><p>Instances of the <code>Buffer</code> class are similar to arrays of integers but
correspond to fixed-sized, raw memory allocations outside the V8 heap.
The size of the <code>Buffer</code> is established when it is created and cannot be
resized.</p></p>
<p><p>The <code>Buffer</code> class is a global within Node.js, making it unlikely that one
would need to ever use <code>require(&#39;buffer&#39;).Buffer</code>.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10, filled with 0x1.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using either fill() or write().
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing [0x1, 0x2, 0x3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].
const buf5 = Buffer.from(&#39;tést&#39;);

// Creates a Buffer containing Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf6 = Buffer.from(&#39;tést&#39;, &#39;latin1&#39;);
</code></pre>


<div class="heading">
<h2>
  <a name="module__buffer_from______buffer_alloc_____and__buffer_allocunsafe___" id="module__buffer_from______buffer_alloc_____and__buffer_allocunsafe___"></a>
  <div class="permalink"><a href="#module__buffer_from______buffer_alloc_____and__buffer_allocunsafe___" class="permalink fas fa-link"></a></div>
  <p><code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code></p>

</h2>
</div>

<p>In versions of Node.js prior to v6, <code>Buffer</code> instances were created using the
<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>
differently based on what arguments are provided:</p>
<ul>
<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>),
allocates a new <code>Buffer</code> object of the specified size. Prior to Node.js 8.0.0,
the memory allocated for such <code>Buffer</code> instances is <em>not</em> initialized and
<em>can contain sensitive data</em>. Such <code>Buffer</code> instances <em>must</em> be subsequently
initialized by using either <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> or by writing to the
<code>Buffer</code> completely. While this behavior is <em>intentional</em> to improve
performance, development experience has demonstrated that a more explicit
distinction is required between creating a fast-but-uninitialized <code>Buffer</code>
versus creating a slower-but-safer <code>Buffer</code>. Starting in Node.js 8.0.0,
<code>Buffer(num)</code> and <code>new Buffer(num)</code> will return a <code>Buffer</code> with initialized
memory.</li>
<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the
passed object&#39;s data into the <code>Buffer</code>.</li>
<li>Passing an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> or a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> returns a <code>Buffer</code> that
shares allocated memory with the given array buffer.</li>
</ul>
<p>Because the behavior of <code>new Buffer()</code> changes significantly based on the type
of value passed as the first argument, applications that do not properly
validate the input arguments passed to <code>new Buffer()</code>, or that fail to
appropriately initialize newly allocated <code>Buffer</code> content, can inadvertently
introduce security and reliability issues into their code.</p>
<p>To make the creation of <code>Buffer</code> instances more reliable and less error prone,
the various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>
and replaced by separate <code>Buffer.from()</code>, <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a>, and
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> methods.</p>
<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors
to one of these new APIs.</em></p>
<ul>
<li><a href="buffer.html#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the provided
octets.</li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a>
returns a new <code>Buffer</code> that <em>shares</em> the same allocated memory as the given
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>.</li>
<li><a href="buffer.html#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the
contents of the given <code>Buffer</code>.</li>
<li><a href="#buffer_class_method_buffer_from_string_encoding"><code>Buffer.from(string[, encoding])</code></a> returns a new <code>Buffer</code>
containing a <em>copy</em> of the provided string.</li>
<li><a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a &quot;filled&quot;
<code>Buffer</code> instance of the specified size. This method can be significantly
slower than <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> but ensures
that newly created <code>Buffer</code> instances never contain old and potentially
sensitive data.</li>
<li><a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> and
<a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a
new <code>Buffer</code> of the specified <code>size</code> whose content <em>must</em> be initialized
using either <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> or written to completely.</li>
</ul>
<p><code>Buffer</code> instances returned by <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> <em>may</em> be allocated off
a shared internal memory pool if <code>size</code> is less than or equal to half
<a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a>. Instances returned by <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> <em>never</em>
use the shared internal memory pool.</p>


<div class="heading">
<h3>
  <a name="module_the____zero_fill_buffers__command_line_option" id="module_the____zero_fill_buffers__command_line_option"></a>
  <div class="permalink"><a href="#module_the____zero_fill_buffers__command_line_option" class="permalink fas fa-link"></a></div>
  <p>The <code>--zero-fill-buffers</code> command line option</p>

</h3>
</div>

<p><p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to
force all newly allocated <code>Buffer</code> instances created using either
<code>new Buffer(size)</code>, <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>, <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> or
<code>new SlowBuffer(size)</code> to be <em>automatically zero-filled</em> upon creation. Use of
this flag <em>changes the default behavior</em> of these methods and <em>can have a significant
impact</em> on performance. Use of the <code>--zero-fill-buffers</code> option is recommended
only when necessary to enforce that newly allocated <code>Buffer</code> instances cannot
contain potentially sensitive data.</p></p>
<p><p>Example:</p></p>
<pre class="prettyprint"><code class="lang-txt">$ node --zero-fill-buffers
&gt; Buffer.allocUnsafe(5);
&lt;Buffer 00 00 00 00 00&gt;
</code></pre>


<div class="heading">
<h3>
  <a name="module_what_makes__buffer_allocunsafe____and__buffer_allocunsafeslow_____unsafe__" id="module_what_makes__buffer_allocunsafe____and__buffer_allocunsafeslow_____unsafe__"></a>
  <div class="permalink"><a href="#module_what_makes__buffer_allocunsafe____and__buffer_allocunsafeslow_____unsafe__" class="permalink fas fa-link"></a></div>
  <p>What makes <code>Buffer.allocUnsafe()</code> and <code>Buffer.allocUnsafeSlow()</code> &quot;unsafe&quot;?</p>

</h3>
</div>

<p>When calling <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> and <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a>, the
segment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While
this design makes the allocation of memory quite fast, the allocated segment of
memory might contain old data that is potentially sensitive. Using a <code>Buffer</code>
created by <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> without <em>completely</em> overwriting the memory
can allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>
<p>While there are clear performance advantages to using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>,
extra care <em>must</em> be taken in order to avoid introducing security
vulnerabilities into an application.</p>


<div class="heading">
<h2>
  <a name="module_buffers_and_character_encodings" id="module_buffers_and_character_encodings"></a>
  <div class="permalink"><a href="#module_buffers_and_character_encodings" class="permalink fas fa-link"></a></div>
  <p>Buffers and Character Encodings</p>

</h2>
</div>

<p><code>Buffer</code> instances are commonly used to represent sequences of encoded characters
such as UTF-8, UCS2, Base64, or even Hex-encoded data. It is possible to
convert back and forth between <code>Buffer</code> instances and ordinary JavaScript strings
by using an explicit character encoding.</p>
<p>Example:</p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from(&#39;hello world&#39;, &#39;ascii&#39;);

// Prints: 68656c6c6f20776f726c64
console.log(buf.toString(&#39;hex&#39;));

// Prints: aGVsbG8gd29ybGQ=
console.log(buf.toString(&#39;base64&#39;));
</code></pre>
<p>The character encodings currently supported by Node.js include:</p>
<ul>
<li><p><code>&#39;ascii&#39;</code> - For 7-bit ASCII data only. This encoding is fast and will strip
the high bit if set.</p>
</li>
<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little-endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>
</li>
<li><p><code>&#39;base64&#39;</code> - Base64 encoding. When creating a <code>Buffer</code> from a string,
this encoding will also correctly accept &quot;URL and Filename Safe Alphabet&quot; as
specified in <a href="https://tools.ietf.org/html/rfc4648#section-5">RFC4648, Section 5</a>.</p>
</li>
<li><p><code>&#39;latin1&#39;</code> - A way of encoding the <code>Buffer</code> into a one-byte encoded string
(as defined by the IANA in <a href="https://tools.ietf.org/html/rfc1345">RFC1345</a>,
page 63, to be the Latin-1 supplement block and C0/C1 control codes).</p>
</li>
<li><p><code>&#39;binary&#39;</code> - Alias for <code>&#39;latin1&#39;</code>.</p>
</li>
<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>
</li>
</ul>
<p><em>Note</em>: Today&#39;s browsers follow the <a href="https://encoding.spec.whatwg.org/">WHATWG Encoding Standard</a> which aliases
both &#39;latin1&#39; and ISO-8859-1 to win-1252. This means that while doing something
like <code>http.get()</code>, if the returned charset is one of those listed in the WHATWG
specification it is possible that the server actually returned
win-1252-encoded data, and using <code>&#39;latin1&#39;</code> encoding may incorrectly decode the
characters.</p>


<div class="heading">
<h2>
  <a name="module_buffers_and_typedarray" id="module_buffers_and_typedarray"></a>
  <div class="permalink"><a href="#module_buffers_and_typedarray" class="permalink fas fa-link"></a></div>
  <p>Buffers and TypedArray</p>

</h2>
</div>

<p><p><code>Buffer</code> instances are also <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> instances. However, there are subtle
incompatibilities with the TypedArray specification in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html"><code>ECMAScript 2015</code></a>.
For example, while <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice"><code>ArrayBuffer#slice()</code></a> creates a copy of the slice, the
implementation of <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> creates a view over the
existing <code>Buffer</code> without copying, making <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> far
more efficient.</p></p>
<p><p>It is also possible to create new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instances from a <code>Buffer</code> with
the following caveats:</p></p>
<p><ol></p>
<p><li><p>The <code>Buffer</code> object&#39;s memory is copied to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>, not shared.</p>
</li></p>
<p><li><p>The <code>Buffer</code> object&#39;s memory is interpreted as an array of distinct
elements, and not as a byte array of the target type. That is,
<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> creates a 4-element <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array"><code>Uint32Array</code></a>
with elements <code>[1, 2, 3, 4]</code>, not a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array"><code>Uint32Array</code></a> with a single element
<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>
</li>
</ol></p>
<p><p>It is possible to create a new <code>Buffer</code> that shares the same allocated memory as
a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instance by using the TypeArray object&#39;s <code>.buffer</code> property.</p></p>
<p><p>Example:</p></p>
<p><pre class="prettyprint"><code class="lang-js">const arr = new Uint16Array(2);</p>
<p>arr[0] = 5000;
arr[1] = 4000;</p>
<p>// Copies the contents of <code>arr</code>
const buf1 = Buffer.from(arr);</p>
<p>// Shares memory with <code>arr</code>
const buf2 = Buffer.from(arr.buffer);</p>
<p>// Prints: &lt;Buffer 88 a0&gt;
console.log(buf1);</p>
<p>// Prints: &lt;Buffer 88 13 a0 0f&gt;
console.log(buf2);</p>
<p>arr[1] = 6000;</p>
<p>// Prints: &lt;Buffer 88 a0&gt;
console.log(buf1);</p>
<p>// Prints: &lt;Buffer 88 13 70 17&gt;
console.log(buf2);
</code></pre></p>
<p><p>Note that when creating a <code>Buffer</code> using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>&#39;s <code>.buffer</code>, it is
possible to use only a portion of the underlying <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> by passing in
<code>byteOffset</code> and <code>length</code> parameters.</p></p>
<p><p>Example:</p></p>
<p><pre class="prettyprint"><code class="lang-js">const arr = new Uint16Array(20);
const buf = Buffer.from(arr.buffer, 0, 16);</p>
<p>// Prints: 16
console.log(buf.length);
</code></pre></p>
<p><p>The <code>Buffer.from()</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from"><code>TypedArray.from()</code></a> have different signatures and
implementations. Specifically, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> variants accept a second
argument that is a mapping function that is invoked on every element of the
typed array:</p></p>
<ul>
<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>
</ul>
<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping
function:</p>
<ul>
<li><a href="buffer.html#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a></li>
<li><a href="buffer.html#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a></li>
<li><a href="#buffer_class_method_buffer_from_string_encoding"><code>Buffer.from(string[, encoding])</code></a></li>
</ul>


<div class="heading">
<h2>
  <a name="module_buffers_and_es6_iteration" id="module_buffers_and_es6_iteration"></a>
  <div class="permalink"><a href="#module_buffers_and_es6_iteration" class="permalink fas fa-link"></a></div>
  <p>Buffers and ES6 iteration</p>

</h2>
</div>

<p><code>Buffer</code> instances can be iterated over using the <a href="https://www.ecma-international.org/ecma-262/6.0/index.html"><code>ECMAScript 2015</code></a> (ES6) <code>for..of</code>
syntax.</p>
<p>Example:</p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([1, 2, 3]);

// Prints:
//   1
//   2
//   3
for (const b of buf) {
  console.log(b);
}
</code></pre>
<p>Additionally, the <a href="#buffer_buf_values"><code>buf.values()</code></a>, <a href="#buffer_buf_keys"><code>buf.keys()</code></a>, and
<a href="#buffer_buf_entries"><code>buf.entries()</code></a> methods can be used to create iterators.</p>


<div class="heading">
<h2>
  <a name="module_buffer_constants" id="module_buffer_constants"></a>
  <div class="permalink"><a href="#module_buffer_constants" class="permalink fas fa-link"></a></div>
  <p>Buffer Constants</p>

</h2>
</div>

<p>Note that <code>buffer.constants</code> is a property on the <code>buffer</code> module returned by
<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>


<div class="heading">
<h3>
  <a name="module_buffer_constants_max_length" id="module_buffer_constants_max_length"></a>
  <div class="permalink"><a href="#module_buffer_constants_max_length" class="permalink fas fa-link"></a></div>
  <p>buffer.constants.MAX_LENGTH</p>

</h3>
</div>

<p><ul></p>
<p><li>{integer} The largest size allowed for a single <code>Buffer</code> instance.</li>
</ul></p>
<p>On 32-bit architectures, this value is <code>(2^30)-1</code> (~1GB).
On 64-bit architectures, this value is <code>(2^31)-1</code> (~2GB).</p>
<p>This value is also available as <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>.</p>


<div class="heading">
<h3>
  <a name="module_buffer_constants_max_string_length" id="module_buffer_constants_max_string_length"></a>
  <div class="permalink"><a href="#module_buffer_constants_max_string_length" class="permalink fas fa-link"></a></div>
  <p>buffer.constants.MAX_STRING_LENGTH</p>

</h3>
</div>

<p><ul></p>
<p><li>{integer} The largest length allowed for a single <code>string</code> instance.</li>
</ul></p>
<p><p>Represents the largest <code>length</code> that a <code>string</code> primitive can have, counted
in UTF-16 code units.</p></p>
<p><p>This value may depend on the JS engine that is being used.</p>
<!-- [end-include:buffer.md] -->
<!-- [start-include:addons.md] --></p>

<div class='expandable-header' id='class_Buffer-expand'>
<div class="heading">
    <h2>
        <a name="class_Buffer" id="class_Buffer"></a>
        <i class='expandable-icon fas fa-caret-right' id="class_Buffer-expand-icon"></i>
        <div class="permalink"><a href="#class_Buffer" class="permalink fas fa-link"></a></div>
        <p>Class: Buffer</p>

    </h2>
</div>

</div>
<div class='expandable-content' id='class_Buffer-expand-content'>
<p>The <code>Buffer</code> class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.</p>


<div class="heading">
<h3>
  <a name="subgroup_class_Buffer_Properties" id="subgroup_class_Buffer_Properties"></a>
  <div class="permalink"><a href="#subgroup_class_Buffer_Properties" class="permalink fas fa-link"></a></div>
  <p>Properties</p>

</h3>
</div>


<div class='expandable-header' id='property_poolSize-expand'>
<div class="heading">
    <h4>
        <a name="property_poolSize" id="property_poolSize"></a>
        <i class='expandable-icon fas fa-caret-right' id="property_poolSize-expand-icon"></i>
        <div class="permalink"><a href="#property_poolSize" class="permalink fas fa-link"></a></div>
        <p><code>poolSize</code> {integer} <strong>Default:</strong> <code>8192</code> </p>

    </h4>
</div>

</div>
<div class='expandable-content' id='property_poolSize-expand-content'>
<p>This is the number of bytes used to determine the size of pre-allocated, internal
<code>Buffer</code> instances used for pooling. This value may be modified.</p>


</div><div class='expandable-header' id='property__index_-expand'>
<div class="heading">
    <h4>
        <a name="property__index_" id="property__index_"></a>
        <i class='expandable-icon fas fa-caret-right' id="property__index_-expand-icon"></i>
        <div class="permalink"><a href="#property__index_" class="permalink fas fa-link"></a></div>
        <p>buf[index]</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='property__index_-expand-content'>
<p><p>The index operator <code>[index]</code> can be used to get and set the octet at position
<code>index</code> in <code>buf</code>. The values refer to individual bytes, so the legal value
range is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p></p>
<p><p>This operator is inherited from <code>Uint8Array</code>, so its behavior on out-of-bounds
access is the same as <code>UInt8Array</code> - that is, getting returns <code>undefined</code> and
setting does nothing.</p></p>
<p><p>Example: Copy an ASCII string into a <code>Buffer</code>, one byte at a time</p></p>
<pre class="prettyprint"><code class="lang-js">const str = &#39;Node.js&#39;;
const buf = Buffer.allocUnsafe(str.length);

for (let i = 0; i &lt; str.length; i++) {
  buf[i] = str.charCodeAt(i);
}

// Prints: Node.js
console.log(buf.toString(&#39;ascii&#39;));
</code></pre>


</div><div class='expandable-header' id='property_buffer-expand'>
<div class="heading">
    <h4>
        <a name="property_buffer" id="property_buffer"></a>
        <i class='expandable-icon fas fa-caret-right' id="property_buffer-expand-icon"></i>
        <div class="permalink"><a href="#property_buffer" class="permalink fas fa-link"></a></div>
        <p>buf.buffer</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='property_buffer-expand-content'>
<p><p>The <code>buffer</code> property references the underlying <code>ArrayBuffer</code> object based on
which this Buffer object is created.</p></p>
<pre class="prettyprint"><code class="lang-js">const arrayBuffer = new ArrayBuffer(16);
const buffer = Buffer.from(arrayBuffer);

console.log(buffer.buffer === arrayBuffer);
// Prints: true
</code></pre>


</div><div class='expandable-header' id='property_length-expand'>
<div class="heading">
    <h4>
        <a name="property_length" id="property_length"></a>
        <i class='expandable-icon fas fa-caret-right' id="property_length-expand-icon"></i>
        <div class="permalink"><a href="#property_length" class="permalink fas fa-link"></a></div>
        <p><code>length</code> {integer} </p>

    </h4>
</div>

</div>
<div class='expandable-content' id='property_length-expand-content'>
<p><p>Returns the amount of memory allocated for <code>buf</code> in bytes. Note that this
does not necessarily reflect the amount of &quot;usable&quot; data within <code>buf</code>.</p></p>
<p><p>Example: Create a <code>Buffer</code> and write a shorter ASCII string to it</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.alloc(1234);

// Prints: 1234
console.log(buf.length);

buf.write(&#39;some string&#39;, 0, &#39;ascii&#39;);

// Prints: 1234
console.log(buf.length);
</code></pre>
<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>
can result in undefined and inconsistent behavior. Applications that wish to
modify the length of a <code>Buffer</code> should therefore treat <code>length</code> as read-only and
use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a> to create a new <code>Buffer</code>.</p>
<p>Examples:</p>
<pre class="prettyprint"><code class="lang-js">let buf = Buffer.allocUnsafe(10);

buf.write(&#39;abcdefghj&#39;, 0, &#39;ascii&#39;);

// Prints: 10
console.log(buf.length);

buf = buf.slice(0, 5);

// Prints: 5
console.log(buf.length);
</code></pre>


</div><div class='expandable-header' id='property_parent-expand'>
<div class="heading">
    <h4>
        <a name="property_parent" id="property_parent"></a>
        <i class='expandable-icon fas fa-caret-right' id="property_parent-expand-icon"></i>
        <div class="permalink"><a href="#property_parent" class="permalink fas fa-link"></a></div>
        <p>buf.parent</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='property_parent-expand-content'>
<p>The <code>buf.parent</code> property is a deprecated alias for <code>buf.buffer</code>.</p>


</div>
<div class="heading">
<h3>
  <a name="subgroup_class_Buffer_Methods" id="subgroup_class_Buffer_Methods"></a>
  <div class="permalink"><a href="#subgroup_class_Buffer_Methods" class="permalink fas fa-link"></a></div>
  <p>Methods</p>

</h3>
</div>


<div class='expandable-header' id='method_compare-expand'>
<div class="heading">
    <h4>
        <a name="method_compare" id="method_compare"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_compare-expand-icon"></i>
        <div class="permalink"><a href="#method_compare" class="permalink fas fa-link"></a></div>
        <p>buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_compare-expand-content'>
<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>
comes before, after, or is the same as <code>target</code> in sort order.
Comparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>
<ul>
<li><code>0</code> is returned if <code>target</code> is the same as <code>buf</code></li>
<li><code>1</code> is returned if <code>target</code> should come <em>before</em> <code>buf</code> when sorted.</li>
<li><code>-1</code> is returned if <code>target</code> should come <em>after</em> <code>buf</code> when sorted.</li>
</ul>
<p>Examples:</p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.from(&#39;ABC&#39;);
const buf2 = Buffer.from(&#39;BCD&#39;);
const buf3 = Buffer.from(&#39;ABCD&#39;);

// Prints: 0
console.log(buf1.compare(buf1));

// Prints: -1
console.log(buf1.compare(buf2));

// Prints: -1
console.log(buf1.compare(buf3));

// Prints: 1
console.log(buf2.compare(buf1));

// Prints: 1
console.log(buf2.compare(buf3));

// Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]
// (This result is equal to: [buf1, buf3, buf2])
console.log([buf1, buf2, buf3].sort(Buffer.compare));
</code></pre>
<p>The optional <code>targetStart</code>, <code>targetEnd</code>, <code>sourceStart</code>, and <code>sourceEnd</code>
arguments can be used to limit the comparison to specific ranges within <code>target</code>
and <code>buf</code> respectively.</p>
<p>Examples:</p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);

// Prints: 0
console.log(buf1.compare(buf2, 5, 9, 0, 4));

// Prints: -1
console.log(buf1.compare(buf2, 0, 6, 4));

// Prints: 1
console.log(buf1.compare(buf2, 5, 6, 5));
</code></pre>
<p>A <code>RangeError</code> will be thrown if: <code>targetStart &lt; 0</code>, <code>sourceStart &lt; 0</code>,
<code>targetEnd &gt; target.byteLength</code> or <code>sourceEnd &gt; source.byteLength</code>.</p>


</div><div class='expandable-header' id='method_copy-expand'>
<div class="heading">
    <h4>
        <a name="method_copy" id="method_copy"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_copy-expand-icon"></i>
        <div class="permalink"><a href="#method_copy" class="permalink fas fa-link"></a></div>
        <p>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_copy-expand-content'>
<p><p>Copies data from a region of <code>buf</code> to a region in <code>target</code> even if the <code>target</code>
memory region overlaps with <code>buf</code>.</p></p>
<p><p>Example: Create two <code>Buffer</code> instances, <code>buf1</code> and <code>buf2</code>, and copy <code>buf1</code> from
byte 16 through byte 19 into <code>buf2</code>, starting at the 8th byte in <code>buf2</code></p></p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);
const buf2 = Buffer.allocUnsafe(26).fill(&#39;!&#39;);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;
  buf1[i] = i + 97;
}

buf1.copy(buf2, 8, 16, 20);

// Prints: !!!!!!!!qrst!!!!!!!!!!!!!
console.log(buf2.toString(&#39;ascii&#39;, 0, 25));
</code></pre>
<p>Example: Create a single <code>Buffer</code> and copy data from one region to an
overlapping region within the same <code>Buffer</code></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;
  buf[i] = i + 97;
}

buf.copy(buf, 0, 4, 10);

// Prints: efghijghijklmnopqrstuvwxyz
console.log(buf.toString());
</code></pre>


</div><div class='expandable-header' id='method_entries-expand'>
<div class="heading">
    <h4>
        <a name="method_entries" id="method_entries"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_entries-expand-icon"></i>
        <div class="permalink"><a href="#method_entries" class="permalink fas fa-link"></a></div>
        <p>buf.entries()</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_entries-expand-content'>
<p><p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> of <code>[index, byte]</code> pairs from the contents of
<code>buf</code>.</p></p>
<p><p>Example: Log the entire contents of a <code>Buffer</code></p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from(&#39;buffer&#39;);

// Prints:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]
for (const pair of buf.entries()) {
  console.log(pair);
}
</code></pre>


</div><div class='expandable-header' id='method_equals-expand'>
<div class="heading">
    <h4>
        <a name="method_equals" id="method_equals"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_equals-expand-icon"></i>
        <div class="permalink"><a href="#method_equals" class="permalink fas fa-link"></a></div>
        <p>buf.equals(otherBuffer)</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_equals-expand-content'>
<p><p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,
<code>false</code> otherwise.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.from(&#39;ABC&#39;);
const buf2 = Buffer.from(&#39;414243&#39;, &#39;hex&#39;);
const buf3 = Buffer.from(&#39;ABCD&#39;);

// Prints: true
console.log(buf1.equals(buf2));

// Prints: false
console.log(buf1.equals(buf3));
</code></pre>


</div><div class='expandable-header' id='method_fill-expand'>
<div class="heading">
    <h4>
        <a name="method_fill" id="method_fill"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_fill-expand-icon"></i>
        <div class="permalink"><a href="#method_fill" class="permalink fas fa-link"></a></div>
        <p>buf.fill(value[, offset[, end]][, encoding])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_fill-expand-content'>
<p><p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,
the entire <code>buf</code> will be filled. This is meant to be a small simplification to
allow the creation and filling of a <code>Buffer</code> to be done on a single line.</p></p>
<p><p>Example: Fill a <code>Buffer</code> with the ASCII character <code>&#39;h&#39;</code></p></p>
<pre class="prettyprint"><code class="lang-js">const b = Buffer.allocUnsafe(50).fill(&#39;h&#39;);

// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
console.log(b.toString());
</code></pre>
<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a String or Integer.</p>
<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,
then only the first bytes of that character that fit into <code>buf</code> are written.</p>
<p>Example: Fill a <code>Buffer</code> with a two-byte character</p>
<pre class="prettyprint"><code class="lang-js">// Prints: &lt;Buffer c8 a2 c8&gt;
console.log(Buffer.allocUnsafe(3).fill(&#39;\u0222&#39;));
</code></pre>
<p>If <code>value</code> contains invalid characters, it is truncated; if no valid
fill data remains, no filling is performed:</p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(5);
// Prints: &lt;Buffer 61 61 61 61 61&gt;
console.log(buf.fill(&#39;a&#39;));
// Prints: &lt;Buffer aa aa aa aa aa&gt;
console.log(buf.fill(&#39;aazz&#39;, &#39;hex&#39;));
// Prints: &lt;Buffer aa aa aa aa aa&gt;
console.log(buf.fill(&#39;zz&#39;, &#39;hex&#39;));
</code></pre>


</div><div class='expandable-header' id='method_includes-expand'>
<div class="heading">
    <h4>
        <a name="method_includes" id="method_includes"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_includes-expand-icon"></i>
        <div class="permalink"><a href="#method_includes" class="permalink fas fa-link"></a></div>
        <p>buf.includes(value[, byteOffset][, encoding])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_includes-expand-content'>
<p><p>Equivalent to <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf() !== -1</code></a>.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from(&#39;this is a buffer&#39;);

// Prints: true
console.log(buf.includes(&#39;this&#39;));

// Prints: true
console.log(buf.includes(&#39;is&#39;));

// Prints: true
console.log(buf.includes(Buffer.from(&#39;a buffer&#39;)));

// Prints: true
// (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.includes(97));

// Prints: false
console.log(buf.includes(Buffer.from(&#39;a buffer example&#39;)));

// Prints: true
console.log(buf.includes(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));

// Prints: false
console.log(buf.includes(&#39;this&#39;, 4));
</code></pre>


</div><div class='expandable-header' id='method_indexOf-expand'>
<div class="heading">
    <h4>
        <a name="method_indexOf" id="method_indexOf"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_indexOf-expand-icon"></i>
        <div class="permalink"><a href="#method_indexOf" class="permalink fas fa-link"></a></div>
        <p>buf.indexOf(value[, byteOffset][, encoding])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_indexOf-expand-content'>
<p>If <code>value</code> is:</p>
<ul>
<li>a string, <code>value</code> is interpreted according to the character encoding in
<code>encoding</code>.</li>
<li>a <code>Buffer</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a>, <code>value</code> will be used in its entirety.
To compare a partial <code>Buffer</code>, use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a>.</li>
<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer
value between <code>0</code> and <code>255</code>.</li>
</ul>
<p>Examples:</p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from(&#39;this is a buffer&#39;);

// Prints: 0
console.log(buf.indexOf(&#39;this&#39;));

// Prints: 2
console.log(buf.indexOf(&#39;is&#39;));

// Prints: 8
console.log(buf.indexOf(Buffer.from(&#39;a buffer&#39;)));

// Prints: 8
// (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.indexOf(97));

// Prints: -1
console.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;)));

// Prints: 8
console.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));

const utf16Buffer = Buffer.from(&#39;\u039a\u0391\u03a3\u03a3\u0395&#39;, &#39;ucs2&#39;);

// Prints: 4
console.log(utf16Buffer.indexOf(&#39;\u03a3&#39;, 0, &#39;ucs2&#39;));

// Prints: 6
console.log(utf16Buffer.indexOf(&#39;\u03a3&#39;, -4, &#39;ucs2&#39;));
</code></pre>
<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a
<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,
an integer between 0 and 255.</p>
<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. Any arguments
that coerce to <code>NaN</code> or 0, like <code>{}</code>, <code>[]</code>, <code>null</code> or <code>undefined</code>, will search
the whole buffer. This behavior matches <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf"><code>String#indexOf()</code></a>.</p>
<pre class="prettyprint"><code class="lang-js">const b = Buffer.from(&#39;abcdef&#39;);

// Passing a value that&#39;s a number, but not a valid byte
// Prints: 2, equivalent to searching for 99 or &#39;c&#39;
console.log(b.indexOf(99.9));
console.log(b.indexOf(256 + 99));

// Passing a byteOffset that coerces to NaN or 0
// Prints: 1, searching the whole buffer
console.log(b.indexOf(&#39;b&#39;, undefined));
console.log(b.indexOf(&#39;b&#39;, {}));
console.log(b.indexOf(&#39;b&#39;, null));
console.log(b.indexOf(&#39;b&#39;, []));
</code></pre>
<p>If <code>value</code> is an empty string or empty <code>Buffer</code> and <code>byteOffset</code> is less
than <code>buf.length</code>, <code>byteOffset</code> will be returned. If <code>value</code> is empty and
<code>byteOffset</code> is at least <code>buf.length</code>, <code>buf.length</code> will be returned.</p>


</div><div class='expandable-header' id='method_keys-expand'>
<div class="heading">
    <h4>
        <a name="method_keys" id="method_keys"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_keys-expand-icon"></i>
        <div class="permalink"><a href="#method_keys" class="permalink fas fa-link"></a></div>
        <p>buf.keys()</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_keys-expand-content'>
<p><p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> of <code>buf</code> keys (indices).</p></p>
<p><p>Example:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from(&#39;buffer&#39;);

// Prints:
//   0
//   1
//   2
//   3
//   4
//   5
for (const key of buf.keys()) {
  console.log(key);
}
</code></pre>


</div><div class='expandable-header' id='method_lastIndexOf-expand'>
<div class="heading">
    <h4>
        <a name="method_lastIndexOf" id="method_lastIndexOf"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_lastIndexOf-expand-icon"></i>
        <div class="permalink"><a href="#method_lastIndexOf" class="permalink fas fa-link"></a></div>
        <p>buf.lastIndexOf(value[, byteOffset][, encoding])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_lastIndexOf-expand-content'>
<p>Identical to <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf()</code></a>, except <code>buf</code> is searched from back to front
instead of front to back.</p>
<p>Examples:</p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from(&#39;this buffer is a buffer&#39;);

// Prints: 0
console.log(buf.lastIndexOf(&#39;this&#39;));

// Prints: 17
console.log(buf.lastIndexOf(&#39;buffer&#39;));

// Prints: 17
console.log(buf.lastIndexOf(Buffer.from(&#39;buffer&#39;)));

// Prints: 15
// (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.lastIndexOf(97));

// Prints: -1
console.log(buf.lastIndexOf(Buffer.from(&#39;yolo&#39;)));

// Prints: 5
console.log(buf.lastIndexOf(&#39;buffer&#39;, 5));

// Prints: -1
console.log(buf.lastIndexOf(&#39;buffer&#39;, 4));

const utf16Buffer = Buffer.from(&#39;\u039a\u0391\u03a3\u03a3\u0395&#39;, &#39;ucs2&#39;);

// Prints: 6
console.log(utf16Buffer.lastIndexOf(&#39;\u03a3&#39;, undefined, &#39;ucs2&#39;));

// Prints: 4
console.log(utf16Buffer.lastIndexOf(&#39;\u03a3&#39;, -5, &#39;ucs2&#39;));
</code></pre>
<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a
<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,
an integer between 0 and 255.</p>
<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. Any arguments
that coerce to <code>NaN</code>, like <code>{}</code> or <code>undefined</code>, will search the whole buffer.
This behavior matches <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf"><code>String#lastIndexOf()</code></a>.</p>
<pre class="prettyprint"><code class="lang-js">const b = Buffer.from(&#39;abcdef&#39;);

// Passing a value that&#39;s a number, but not a valid byte
// Prints: 2, equivalent to searching for 99 or &#39;c&#39;
console.log(b.lastIndexOf(99.9));
console.log(b.lastIndexOf(256 + 99));

// Passing a byteOffset that coerces to NaN
// Prints: 1, searching the whole buffer
console.log(b.lastIndexOf(&#39;b&#39;, undefined));
console.log(b.lastIndexOf(&#39;b&#39;, {}));

// Passing a byteOffset that coerces to 0
// Prints: -1, equivalent to passing 0
console.log(b.lastIndexOf(&#39;b&#39;, null));
console.log(b.lastIndexOf(&#39;b&#39;, []));
</code></pre>
<p>If <code>value</code> is an empty string or empty <code>Buffer</code>, <code>byteOffset</code> will be returned.</p>


</div><div class='expandable-header' id='method_readDoubleBE-expand'>
<div class="heading">
    <h4>
        <a name="method_readDoubleBE" id="method_readDoubleBE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readDoubleBE-expand-icon"></i>
        <div class="permalink"><a href="#method_readDoubleBE" class="permalink fas fa-link"></a></div>
        <p>buf.readDoubleBE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readDoubleBE-expand-content'>
<p><p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns
little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

// Prints: 8.20788039913184e-304
console.log(buf.readDoubleBE());

// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readDoubleLE(1));

// Warning: reads passed end of buffer!
// This will result in a segmentation fault! Don&#39;t do this!
console.log(buf.readDoubleLE(1, true));
</code></pre>


</div><div class='expandable-header' id='method_readDoubleLE-expand'>
<div class="heading">
    <h4>
        <a name="method_readDoubleLE" id="method_readDoubleLE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readDoubleLE-expand-icon"></i>
        <div class="permalink"><a href="#method_readDoubleLE" class="permalink fas fa-link"></a></div>
        <p>buf.readDoubleLE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readDoubleLE-expand-content'>
<p><p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns
little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

// Prints: 8.20788039913184e-304
console.log(buf.readDoubleBE());

// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readDoubleLE(1));

// Warning: reads passed end of buffer!
// This will result in a segmentation fault! Don&#39;t do this!
console.log(buf.readDoubleLE(1, true));
</code></pre>


</div><div class='expandable-header' id='method_readFloatBE-expand'>
<div class="heading">
    <h4>
        <a name="method_readFloatBE" id="method_readFloatBE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readFloatBE-expand-icon"></i>
        <div class="permalink"><a href="#method_readFloatBE" class="permalink fas fa-link"></a></div>
        <p>buf.readFloatBE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readFloatBE-expand-content'>
<p><p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns
little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4]);

// Prints: 2.387939260590663e-38
console.log(buf.readFloatBE());

// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readFloatLE(1));

// Warning: reads passed end of buffer!
// This will result in a segmentation fault! Don&#39;t do this!
console.log(buf.readFloatLE(1, true));
</code></pre>


</div><div class='expandable-header' id='method_readFloatLE-expand'>
<div class="heading">
    <h4>
        <a name="method_readFloatLE" id="method_readFloatLE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readFloatLE-expand-icon"></i>
        <div class="permalink"><a href="#method_readFloatLE" class="permalink fas fa-link"></a></div>
        <p>buf.readFloatLE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readFloatLE-expand-content'>
<p><p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns
little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4]);

// Prints: 2.387939260590663e-38
console.log(buf.readFloatBE());

// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readFloatLE(1));

// Warning: reads passed end of buffer!
// This will result in a segmentation fault! Don&#39;t do this!
console.log(buf.readFloatLE(1, true));
</code></pre>


</div><div class='expandable-header' id='method_readInt8-expand'>
<div class="heading">
    <h4>
        <a name="method_readInt8" id="method_readInt8"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readInt8-expand-icon"></i>
        <div class="permalink"><a href="#method_readInt8" class="permalink fas fa-link"></a></div>
        <p>buf.readInt8(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readInt8-expand-content'>
<p><p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([-1, 5]);

// Prints: -1
console.log(buf.readInt8(0));

// Prints: 5
console.log(buf.readInt8(1));

// Throws an exception: RangeError: Index out of range
console.log(buf.readInt8(2));
</code></pre>


</div><div class='expandable-header' id='method_readInt16BE-expand'>
<div class="heading">
    <h4>
        <a name="method_readInt16BE" id="method_readInt16BE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readInt16BE-expand-icon"></i>
        <div class="permalink"><a href="#method_readInt16BE" class="permalink fas fa-link"></a></div>
        <p>buf.readInt16BE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readInt16BE-expand-content'>
<p><p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt16BE()</code> returns big endian,
<code>readInt16LE()</code> returns little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0, 5]);

// Prints: 5
console.log(buf.readInt16BE());

// Prints: 1280
console.log(buf.readInt16LE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readInt16LE(1));
</code></pre>


</div><div class='expandable-header' id='method_readInt16LE-expand'>
<div class="heading">
    <h4>
        <a name="method_readInt16LE" id="method_readInt16LE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readInt16LE-expand-icon"></i>
        <div class="permalink"><a href="#method_readInt16LE" class="permalink fas fa-link"></a></div>
        <p>buf.readInt16LE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readInt16LE-expand-content'>
<p><p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt16BE()</code> returns big endian,
<code>readInt16LE()</code> returns little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0, 5]);

// Prints: 5
console.log(buf.readInt16BE());

// Prints: 1280
console.log(buf.readInt16LE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readInt16LE(1));
</code></pre>


</div><div class='expandable-header' id='method_readInt32BE-expand'>
<div class="heading">
    <h4>
        <a name="method_readInt32BE" id="method_readInt32BE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readInt32BE-expand-icon"></i>
        <div class="permalink"><a href="#method_readInt32BE" class="permalink fas fa-link"></a></div>
        <p>buf.readInt32BE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readInt32BE-expand-content'>
<p><p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0, 0, 0, 5]);

// Prints: 5
console.log(buf.readInt32BE());

// Prints: 83886080
console.log(buf.readInt32LE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readInt32LE(1));
</code></pre>


</div><div class='expandable-header' id='method_readInt32LE-expand'>
<div class="heading">
    <h4>
        <a name="method_readInt32LE" id="method_readInt32LE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readInt32LE-expand-icon"></i>
        <div class="permalink"><a href="#method_readInt32LE" class="permalink fas fa-link"></a></div>
        <p>buf.readInt32LE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readInt32LE-expand-content'>
<p><p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0, 0, 0, 5]);

// Prints: 5
console.log(buf.readInt32BE());

// Prints: 83886080
console.log(buf.readInt32LE());

// Throws an exception: RangeError: Index out of range
console.log(buf.readInt32LE(1));
</code></pre>


</div><div class='expandable-header' id='method_readIntBE-expand'>
<div class="heading">
    <h4>
        <a name="method_readIntBE" id="method_readIntBE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readIntBE-expand-icon"></i>
        <div class="permalink"><a href="#method_readIntBE" class="permalink fas fa-link"></a></div>
        <p>buf.readIntBE(offset, byteLength[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readIntBE-expand-content'>
<p><p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as a two&#39;s complement signed value. Supports up to 48
bits of accuracy.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// Prints: -546f87a9cbee
console.log(buf.readIntLE(0, 6).toString(16));

// Prints: 1234567890ab
console.log(buf.readIntBE(0, 6).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readIntBE(1, 6).toString(16));
</code></pre>


</div><div class='expandable-header' id='method_readIntLE-expand'>
<div class="heading">
    <h4>
        <a name="method_readIntLE" id="method_readIntLE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readIntLE-expand-icon"></i>
        <div class="permalink"><a href="#method_readIntLE" class="permalink fas fa-link"></a></div>
        <p>buf.readIntLE(offset, byteLength[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readIntLE-expand-content'>
<p><p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as a two&#39;s complement signed value. Supports up to 48
bits of accuracy.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// Prints: -546f87a9cbee
console.log(buf.readIntLE(0, 6).toString(16));

// Prints: 1234567890ab
console.log(buf.readIntBE(0, 6).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readIntBE(1, 6).toString(16));
</code></pre>


</div><div class='expandable-header' id='method_readUInt8-expand'>
<div class="heading">
    <h4>
        <a name="method_readUInt8" id="method_readUInt8"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readUInt8-expand-icon"></i>
        <div class="permalink"><a href="#method_readUInt8" class="permalink fas fa-link"></a></div>
        <p>buf.readUInt8(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readUInt8-expand-content'>
<p><p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([1, -2]);

// Prints: 1
console.log(buf.readUInt8(0));

// Prints: 254
console.log(buf.readUInt8(1));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUInt8(2));
</code></pre>


</div><div class='expandable-header' id='method_readUInt16BE-expand'>
<div class="heading">
    <h4>
        <a name="method_readUInt16BE" id="method_readUInt16BE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readUInt16BE-expand-icon"></i>
        <div class="permalink"><a href="#method_readUInt16BE" class="permalink fas fa-link"></a></div>
        <p>buf.readUInt16BE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readUInt16BE-expand-content'>
<p><p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>
returns little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56]);

// Prints: 1234
console.log(buf.readUInt16BE(0).toString(16));

// Prints: 3412
console.log(buf.readUInt16LE(0).toString(16));

// Prints: 3456
console.log(buf.readUInt16BE(1).toString(16));

// Prints: 5634
console.log(buf.readUInt16LE(1).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUInt16LE(2).toString(16));
</code></pre>


</div><div class='expandable-header' id='method_readUInt16LE-expand'>
<div class="heading">
    <h4>
        <a name="method_readUInt16LE" id="method_readUInt16LE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readUInt16LE-expand-icon"></i>
        <div class="permalink"><a href="#method_readUInt16LE" class="permalink fas fa-link"></a></div>
        <p>buf.readUInt16LE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readUInt16LE-expand-content'>
<p><p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>
returns little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56]);

// Prints: 1234
console.log(buf.readUInt16BE(0).toString(16));

// Prints: 3412
console.log(buf.readUInt16LE(0).toString(16));

// Prints: 3456
console.log(buf.readUInt16BE(1).toString(16));

// Prints: 5634
console.log(buf.readUInt16LE(1).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUInt16LE(2).toString(16));
</code></pre>


</div><div class='expandable-header' id='method_readUInt32BE-expand'>
<div class="heading">
    <h4>
        <a name="method_readUInt32BE" id="method_readUInt32BE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readUInt32BE-expand-icon"></i>
        <div class="permalink"><a href="#method_readUInt32BE" class="permalink fas fa-link"></a></div>
        <p>buf.readUInt32BE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readUInt32BE-expand-content'>
<p><p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt32BE()</code> returns big endian,
<code>readUInt32LE()</code> returns little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

// Prints: 12345678
console.log(buf.readUInt32BE(0).toString(16));

// Prints: 78563412
console.log(buf.readUInt32LE(0).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUInt32LE(1).toString(16));
</code></pre>


</div><div class='expandable-header' id='method_readUInt32LE-expand'>
<div class="heading">
    <h4>
        <a name="method_readUInt32LE" id="method_readUInt32LE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readUInt32LE-expand-icon"></i>
        <div class="permalink"><a href="#method_readUInt32LE" class="permalink fas fa-link"></a></div>
        <p>buf.readUInt32LE(offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readUInt32LE-expand-content'>
<p><p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt32BE()</code> returns big endian,
<code>readUInt32LE()</code> returns little endian).</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

// Prints: 12345678
console.log(buf.readUInt32BE(0).toString(16));

// Prints: 78563412
console.log(buf.readUInt32LE(0).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUInt32LE(1).toString(16));
</code></pre>


</div><div class='expandable-header' id='method_readUIntBE-expand'>
<div class="heading">
    <h4>
        <a name="method_readUIntBE" id="method_readUIntBE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readUIntBE-expand-icon"></i>
        <div class="permalink"><a href="#method_readUIntBE" class="permalink fas fa-link"></a></div>
        <p>buf.readUIntBE(offset, byteLength[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readUIntBE-expand-content'>
<p><p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as an unsigned integer. Supports up to 48
bits of accuracy.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// Prints: 1234567890ab
console.log(buf.readUIntBE(0, 6).toString(16));

// Prints: ab9078563412
console.log(buf.readUIntLE(0, 6).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUIntBE(1, 6).toString(16));
</code></pre>


</div><div class='expandable-header' id='method_readUIntLE-expand'>
<div class="heading">
    <h4>
        <a name="method_readUIntLE" id="method_readUIntLE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_readUIntLE-expand-icon"></i>
        <div class="permalink"><a href="#method_readUIntLE" class="permalink fas fa-link"></a></div>
        <p>buf.readUIntLE(offset, byteLength[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_readUIntLE-expand-content'>
<p><p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as an unsigned integer. Supports up to 48
bits of accuracy.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// Prints: 1234567890ab
console.log(buf.readUIntBE(0, 6).toString(16));

// Prints: ab9078563412
console.log(buf.readUIntLE(0, 6).toString(16));

// Throws an exception: RangeError: Index out of range
console.log(buf.readUIntBE(1, 6).toString(16));
</code></pre>


</div><div class='expandable-header' id='method_slice-expand'>
<div class="heading">
    <h4>
        <a name="method_slice" id="method_slice"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_slice-expand-icon"></i>
        <div class="permalink"><a href="#method_slice" class="permalink fas fa-link"></a></div>
        <p>buf.slice([start[, end]])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_slice-expand-content'>
<p><p>Returns a new <code>Buffer</code> that references the same memory as the original, but
offset and cropped by the <code>start</code> and <code>end</code> indices.</p></p>
<p><p>Specifying <code>end</code> greater than <a href="#buffer_buf_length"><code>buf.length</code></a> will return the same result as
that of <code>end</code> equal to <a href="#buffer_buf_length"><code>buf.length</code></a>.</p></p>
<p><p><em>Note</em>: Modifying the new <code>Buffer</code> slice will modify the memory in the
original <code>Buffer</code> because the allocated memory of the two objects overlap.</p></p>
<p><p>Example: Create a <code>Buffer</code> with the ASCII alphabet, take a slice, and then modify
one byte from the original <code>Buffer</code></p></p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;
  buf1[i] = i + 97;
}

const buf2 = buf1.slice(0, 3);

// Prints: abc
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));

buf1[0] = 33;

// Prints: !bc
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));
</code></pre>
<p>Specifying negative indexes causes the slice to be generated relative to the
end of <code>buf</code> rather than the beginning.</p>
<p>Examples:</p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from(&#39;buffer&#39;);

// Prints: buffe
// (Equivalent to buf.slice(0, 5))
console.log(buf.slice(-6, -1).toString());

// Prints: buff
// (Equivalent to buf.slice(0, 4))
console.log(buf.slice(-6, -2).toString());

// Prints: uff
// (Equivalent to buf.slice(1, 4))
console.log(buf.slice(-5, -2).toString());
</code></pre>


</div><div class='expandable-header' id='method_swap16-expand'>
<div class="heading">
    <h4>
        <a name="method_swap16" id="method_swap16"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_swap16-expand-icon"></i>
        <div class="permalink"><a href="#method_swap16" class="permalink fas fa-link"></a></div>
        <p>buf.swap16()</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_swap16-expand-content'>
<p><p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the byte-order
<em>in-place</em>. Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 2.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap16();

// Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;
console.log(buf1);

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// Throws an exception: RangeError: Buffer size must be a multiple of 16-bits
buf2.swap16();
</code></pre>


</div><div class='expandable-header' id='method_swap32-expand'>
<div class="heading">
    <h4>
        <a name="method_swap32" id="method_swap32"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_swap32-expand-icon"></i>
        <div class="permalink"><a href="#method_swap32" class="permalink fas fa-link"></a></div>
        <p>buf.swap32()</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_swap32-expand-content'>
<p><p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the byte-order
<em>in-place</em>. Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 4.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap32();

// Prints: &lt;Buffer 04 03 02 01 08 07 06 05&gt;
console.log(buf1);

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// Throws an exception: RangeError: Buffer size must be a multiple of 32-bits
buf2.swap32();
</code></pre>


</div><div class='expandable-header' id='method_swap64-expand'>
<div class="heading">
    <h4>
        <a name="method_swap64" id="method_swap64"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_swap64-expand-icon"></i>
        <div class="permalink"><a href="#method_swap64" class="permalink fas fa-link"></a></div>
        <p>buf.swap64()</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_swap64-expand-content'>
<p>Interprets <code>buf</code> as an array of 64-bit numbers and swaps the byte-order <em>in-place</em>.
Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 8.</p>
<p>Examples:</p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap64();

// Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;
console.log(buf1);

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// Throws an exception: RangeError: Buffer size must be a multiple of 64-bits
buf2.swap64();
</code></pre>
<p>Note that JavaScript cannot encode 64-bit integers. This method is intended
for working with 64-bit floats.</p>


</div><div class='expandable-header' id='method_toJSON-expand'>
<div class="heading">
    <h4>
        <a name="method_toJSON" id="method_toJSON"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_toJSON-expand-icon"></i>
        <div class="permalink"><a href="#method_toJSON" class="permalink fas fa-link"></a></div>
        <p>buf.toJSON()</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_toJSON-expand-content'>
<p><p>Returns a JSON representation of <code>buf</code>. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> implicitly calls
this function when stringifying a <code>Buffer</code> instance.</p></p>
<p><p>Example:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

// Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}
console.log(json);

const copy = JSON.parse(json, (key, value) =&gt; {
  return value &amp;&amp; value.type === &#39;Buffer&#39; ?
    Buffer.from(value.data) :
    value;
});

// Prints: &lt;Buffer 01 02 03 04 05&gt;
console.log(copy);
</code></pre>


</div><div class='expandable-header' id='method_toString-expand'>
<div class="heading">
    <h4>
        <a name="method_toString" id="method_toString"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_toString-expand-icon"></i>
        <div class="permalink"><a href="#method_toString" class="permalink fas fa-link"></a></div>
        <p>buf.toString([encoding[, start[, end]]])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_toString-expand-content'>
<p><p>Decodes <code>buf</code> to a string according to the specified character encoding in
<code>encoding</code>. <code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p></p>
<p><p>The maximum length of a string instance (in UTF-16 code units) is available
as <a href="#buffer_buffer_constants_max_string_length"><code>buffer.constants.MAX_STRING_LENGTH</code></a>.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;
  buf1[i] = i + 97;
}

// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString(&#39;ascii&#39;));

// Prints: abcde
console.log(buf1.toString(&#39;ascii&#39;, 0, 5));

const buf2 = Buffer.from(&#39;tést&#39;);

// Prints: 74c3a97374
console.log(buf2.toString(&#39;hex&#39;));

// Prints: té
console.log(buf2.toString(&#39;utf8&#39;, 0, 3));

// Prints: té
console.log(buf2.toString(undefined, 0, 3));
</code></pre>


</div><div class='expandable-header' id='method_values-expand'>
<div class="heading">
    <h4>
        <a name="method_values" id="method_values"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_values-expand-icon"></i>
        <div class="permalink"><a href="#method_values" class="permalink fas fa-link"></a></div>
        <p>buf.values()</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_values-expand-content'>
<p><p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> for <code>buf</code> values (bytes). This function is
called automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.from(&#39;buffer&#39;);

// Prints:
//   98
//   117
//   102
//   102
//   101
//   114
for (const value of buf.values()) {
  console.log(value);
}

// Prints:
//   98
//   117
//   102
//   102
//   101
//   114
for (const value of buf) {
  console.log(value);
}
</code></pre>


</div><div class='expandable-header' id='method_write-expand'>
<div class="heading">
    <h4>
        <a name="method_write" id="method_write"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_write-expand-icon"></i>
        <div class="permalink"><a href="#method_write" class="permalink fas fa-link"></a></div>
        <p>buf.write(string[, offset[, length]][, encoding])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_write-expand-content'>
<p><p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in <code>encoding</code>.
The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did not contain
enough space to fit the entire string, only a partial amount of <code>string</code> will
be written. However, partially encoded characters will not be written.</p></p>
<p><p>Example:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(256);

const len = buf.write(&#39;\u00bd + \u00bc = \u00be&#39;, 0);

// Prints: 12 bytes: ½ + ¼ = ¾
console.log(`${len} bytes: ${buf.toString(&#39;utf8&#39;, 0, len)}`);
</code></pre>


</div><div class='expandable-header' id='method_writeDoubleBE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeDoubleBE" id="method_writeDoubleBE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeDoubleBE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeDoubleBE" class="permalink fas fa-link"></a></div>
        <p>buf.writeDoubleBE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeDoubleBE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when
<code>value</code> is anything other than a 64-bit double.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeDoubleLE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeDoubleLE" id="method_writeDoubleLE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeDoubleLE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeDoubleLE" class="permalink fas fa-link"></a></div>
        <p>buf.writeDoubleLE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeDoubleLE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when
<code>value</code> is anything other than a 64-bit double.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeFloatBE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeFloatBE" id="method_writeFloatBE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeFloatBE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeFloatBE" class="permalink fas fa-link"></a></div>
        <p>buf.writeFloatBE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeFloatBE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when
<code>value</code> is anything other than a 32-bit float.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

// Prints: &lt;Buffer 4f 4a fe bb&gt;
console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

// Prints: &lt;Buffer bb fe 4a 4f&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeFloatLE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeFloatLE" id="method_writeFloatLE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeFloatLE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeFloatLE" class="permalink fas fa-link"></a></div>
        <p>buf.writeFloatLE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeFloatLE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when
<code>value</code> is anything other than a 32-bit float.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

// Prints: &lt;Buffer 4f 4a fe bb&gt;
console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

// Prints: &lt;Buffer bb fe 4a 4f&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeInt8-expand'>
<div class="heading">
    <h4>
        <a name="method_writeInt8" id="method_writeInt8"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeInt8-expand-icon"></i>
        <div class="permalink"><a href="#method_writeInt8" class="permalink fas fa-link"></a></div>
        <p>buf.writeInt8(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeInt8-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a valid
signed 8-bit integer. Behavior is undefined when <code>value</code> is anything other than
a signed 8-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(2);

buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);

// Prints: &lt;Buffer 02 fe&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeInt16BE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeInt16BE" id="method_writeInt16BE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeInt16BE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeInt16BE" class="permalink fas fa-link"></a></div>
        <p>buf.writeInt16BE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeInt16BE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is undefined
when <code>value</code> is anything other than a signed 16-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeInt16BE(0x0102, 0);
buf.writeInt16LE(0x0304, 2);

// Prints: &lt;Buffer 01 02 04 03&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeInt16LE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeInt16LE" id="method_writeInt16LE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeInt16LE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeInt16LE" class="permalink fas fa-link"></a></div>
        <p>buf.writeInt16LE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeInt16LE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is undefined
when <code>value</code> is anything other than a signed 16-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeInt16BE(0x0102, 0);
buf.writeInt16LE(0x0304, 2);

// Prints: &lt;Buffer 01 02 04 03&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeInt32BE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeInt32BE" id="method_writeInt32BE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeInt32BE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeInt32BE" class="permalink fas fa-link"></a></div>
        <p>buf.writeInt32BE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeInt32BE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is undefined
when <code>value</code> is anything other than a signed 32-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeInt32BE(0x01020304, 0);
buf.writeInt32LE(0x05060708, 4);

// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeInt32LE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeInt32LE" id="method_writeInt32LE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeInt32LE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeInt32LE" class="permalink fas fa-link"></a></div>
        <p>buf.writeInt32LE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeInt32LE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is undefined
when <code>value</code> is anything other than a signed 32-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeInt32BE(0x01020304, 0);
buf.writeInt32LE(0x05060708, 4);

// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeIntBE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeIntBE" id="method_writeIntBE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeIntBE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeIntBE" class="permalink fas fa-link"></a></div>
        <p>buf.writeIntBE(value, offset, byteLength[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeIntBE-expand-content'>
<p><p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than a signed integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeIntBE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
console.log(buf);

buf.writeIntLE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeIntLE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeIntLE" id="method_writeIntLE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeIntLE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeIntLE" class="permalink fas fa-link"></a></div>
        <p>buf.writeIntLE(value, offset, byteLength[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeIntLE-expand-content'>
<p><p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than a signed integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeIntBE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
console.log(buf);

buf.writeIntLE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeUInt8-expand'>
<div class="heading">
    <h4>
        <a name="method_writeUInt8" id="method_writeUInt8"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeUInt8-expand-icon"></i>
        <div class="permalink"><a href="#method_writeUInt8" class="permalink fas fa-link"></a></div>
        <p>buf.writeUInt8(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeUInt8-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a
valid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything
other than an unsigned 8-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

// Prints: &lt;Buffer 03 04 23 42&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeUInt16BE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeUInt16BE" id="method_writeUInt16BE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeUInt16BE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeUInt16BE" class="permalink fas fa-link"></a></div>
        <p>buf.writeUInt16BE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeUInt16BE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

// Prints: &lt;Buffer de ad be ef&gt;
console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

// Prints: &lt;Buffer ad de ef be&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeUInt16LE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeUInt16LE" id="method_writeUInt16LE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeUInt16LE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeUInt16LE" class="permalink fas fa-link"></a></div>
        <p>buf.writeUInt16LE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeUInt16LE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

// Prints: &lt;Buffer de ad be ef&gt;
console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

// Prints: &lt;Buffer ad de ef be&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeUInt32BE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeUInt32BE" id="method_writeUInt32BE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeUInt32BE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeUInt32BE" class="permalink fas fa-link"></a></div>
        <p>buf.writeUInt32BE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeUInt32BE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

// Prints: &lt;Buffer fe ed fa ce&gt;
console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

// Prints: &lt;Buffer ce fa ed fe&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeUInt32LE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeUInt32LE" id="method_writeUInt32LE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeUInt32LE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeUInt32LE" class="permalink fas fa-link"></a></div>
        <p>buf.writeUInt32LE(value, offset[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeUInt32LE-expand-content'>
<p><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

// Prints: &lt;Buffer fe ed fa ce&gt;
console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

// Prints: &lt;Buffer ce fa ed fe&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeUIntBE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeUIntBE" id="method_writeUIntBE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeUIntBE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeUIntBE" class="permalink fas fa-link"></a></div>
        <p>buf.writeUIntBE(value, offset, byteLength[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeUIntBE-expand-content'>
<p><p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than an unsigned integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
console.log(buf);

buf.writeUIntLE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
console.log(buf);
</code></pre>


</div><div class='expandable-header' id='method_writeUIntLE-expand'>
<div class="heading">
    <h4>
        <a name="method_writeUIntLE" id="method_writeUIntLE"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_writeUIntLE-expand-icon"></i>
        <div class="permalink"><a href="#method_writeUIntLE" class="permalink fas fa-link"></a></div>
        <p>buf.writeUIntLE(value, offset, byteLength[, noAssert])</p>

    </h4>
</div>

</div>
<div class='expandable-content' id='method_writeUIntLE-expand-content'>
<p><p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than an unsigned integer.</p></p>
<p><p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the resulting behavior is undefined.</p></p>
<p><p>Examples:</p></p>
<pre class="prettyprint"><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
console.log(buf);

buf.writeUIntLE(0x1234567890ab, 0, 6);

// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
console.log(buf);
</code></pre>


</div>
</div><div class='expandable-header' id='class_SlowBuffer-expand'>
<div class="heading">
    <h2>
        <a name="class_SlowBuffer" id="class_SlowBuffer"></a>
        <i class='expandable-icon fas fa-caret-right' id="class_SlowBuffer-expand-icon"></i>
        <div class="permalink"><a href="#class_SlowBuffer" class="permalink fas fa-link"></a></div>
        <p>Class: SlowBuffer</p>

    </h2>
</div>

</div>
<div class='expandable-content' id='class_SlowBuffer-expand-content'>
<p>Returns an un-pooled <code>Buffer</code>.</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated <code>Buffer</code> instances, by default allocations under 4KB are sliced from a
single larger allocated object.</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time, it may be appropriate to create an
un-pooled <code>Buffer</code> instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>
<p>Example:</p>
<pre class="prettyprint"><code class="lang-js">// Need to keep around a few small chunks of memory
const store = [];

socket.on(&#39;readable&#39;, () =&gt; {
  const data = socket.read();

  // Allocate for retained data
  const sb = SlowBuffer(10);

  // Copy the data into the new allocation
  data.copy(sb, 0, 0, 10);

  store.push(sb);
});
</code></pre>
<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer
has observed undue memory retention in their applications.</p>


</div><div class='expandable-header' id='property_INSPECT_MAX_BYTES-expand'>
<div class="heading">
    <h2>
        <a name="property_INSPECT_MAX_BYTES" id="property_INSPECT_MAX_BYTES"></a>
        <i class='expandable-icon fas fa-caret-right' id="property_INSPECT_MAX_BYTES-expand-icon"></i>
        <div class="permalink"><a href="#property_INSPECT_MAX_BYTES" class="permalink fas fa-link"></a></div>
        <p><code>INSPECT_MAX_BYTES</code> {integer} <strong>Default:</strong> <code>50</code> </p>

    </h2>
</div>

</div>
<div class='expandable-content' id='property_INSPECT_MAX_BYTES-expand-content'>
<p>Returns the maximum number of bytes that will be returned when
<code>buf.inspect()</code> is called. This can be overridden by user modules. See
<a href="#util_util_inspect_object_options"><code>util.inspect()</code></a> for more details on <code>buf.inspect()</code> behavior.</p>
<p>Note that this is a property on the <code>buffer</code> module returned by
<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>


</div><div class='expandable-header' id='property_kMaxLength-expand'>
<div class="heading">
    <h2>
        <a name="property_kMaxLength" id="property_kMaxLength"></a>
        <i class='expandable-icon fas fa-caret-right' id="property_kMaxLength-expand-icon"></i>
        <div class="permalink"><a href="#property_kMaxLength" class="permalink fas fa-link"></a></div>
        <p><code>kMaxLength</code> {integer} The largest size allowed for a single <code>Buffer</code> instance. </p>

    </h2>
</div>

</div>
<div class='expandable-content' id='property_kMaxLength-expand-content'>
<p>An alias for <a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a></p>
<p>Note that this is a property on the <code>buffer</code> module returned by
<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>


</div><div class='expandable-header' id='method_transcode-expand'>
<div class="heading">
    <h2>
        <a name="method_transcode" id="method_transcode"></a>
        <i class='expandable-icon fas fa-caret-right' id="method_transcode-expand-icon"></i>
        <div class="permalink"><a href="#method_transcode" class="permalink fas fa-link"></a></div>
        <p>buffer.transcode(source, fromEnc, toEnc)</p>

    </h2>
</div>

</div>
<div class='expandable-content' id='method_transcode-expand-content'>
<p>Re-encodes the given <code>Buffer</code> or <code>Uint8Array</code> instance from one character
encoding to another. Returns a new <code>Buffer</code> instance.</p>
<p>Throws if the <code>fromEnc</code> or <code>toEnc</code> specify invalid character encodings or if
conversion from <code>fromEnc</code> to <code>toEnc</code> is not permitted.</p>
<p>The transcoding process will use substitution characters if a given byte
sequence cannot be adequately represented in the target encoding. For instance:</p>
<pre class="prettyprint"><code class="lang-js">const buffer = require(&#39;buffer&#39;);

const newBuf = buffer.transcode(Buffer.from(&#39;€&#39;), &#39;utf8&#39;, &#39;ascii&#39;);
console.log(newBuf.toString(&#39;ascii&#39;));
// Prints: &#39;?&#39;
</code></pre>
<p>Because the Euro (<code>€</code>) sign is not representable in US-ASCII, it is replaced
with <code>?</code> in the transcoded <code>Buffer</code>.</p>
<p>Note that this is a property on the <code>buffer</code> module returned by
<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>


</div>

  <div class="footer">
    <p>Some footer text. Optional. Copyright &copy; whenever by your bidness.</p>
    <p>Dubbed by <img src="images/mixtape.png" title="Dubbed by mixtape." style="width:40px;position:relative;top:8px"></img> mixtape.</p>
  </div>

  </div>
  </body>
</html>