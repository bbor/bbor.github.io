<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>mixtape page for tls_(ssl)</title>
    <script data-main="js/setup" src="js/require.js"></script>
    <link rel="stylesheet" href="fonts/fonts.css" />
    <link rel="stylesheet" href="fonts/fontawesome-all.min.css" />
    <link rel="stylesheet" href="css/layout.css" />
    <link rel="stylesheet" href="toc/themes/default/style.min.css" />
    <link rel="stylesheet" href="css/design.css" />
  </head>
  <body>

  <div id="control-panel">
    <div id="control-strip-h">
      <div id="control-strip-h-find"><i class="fas fa-crosshairs"></i></div>
      <div id="control-strip-h-toc"><i class="fas fa-bars"></i></div>
    </div>
    <div id="controls">
      <div id="control-find">
        <div id="control-find-content"><input id="find" class="typeahead" placeholder="Find something..."></div>
      </div>
      <div id="control-toc">
        <div id="control-toc-content"><div id="toc"></div></div>
      </div>
    </div>
  </div>
  <div id="control-strip-v">
    <div id="control-strip-v-find"><i class="fas fa-crosshairs"></i></div>
    <div id="control-strip-v-toc"><i class="fas fa-bars"></i></div>
  </div>

  <div id="content">

  
       <div class="heading">
          <h1>
            <a name="module_tls__ssl_" id="module_tls__ssl_"></a>
            <div class="permalink"><a href="#module_tls__ssl_" class="permalink fas fa-link"></a></div>
            <p>TLS (SSL)</p>

          </h1>
        </div><p><p>The <code>tls</code> module provides an implementation of the Transport Layer Security
(TLS) and Secure Socket Layer (SSL) protocols that is built on top of OpenSSL.
The module can be accessed using:</p></p>
<pre class="prettyprint"><code class="lang-js">const tls = require(&#39;tls&#39;);
</code></pre>

       <div class="heading">
          <h2>
            <a name="module_tls_ssl_concepts" id="module_tls_ssl_concepts"></a>
            <div class="permalink"><a href="#module_tls_ssl_concepts" class="permalink fas fa-link"></a></div>
            <p>TLS/SSL Concepts</p>

          </h1>
        </div><section><p><p>The TLS/SSL is a public/private key infrastructure (PKI). For most common
cases, each client and server must have a <em>private key</em>.</p></p>
<p><p>Private keys can be generated in multiple ways. The example below illustrates
use of the OpenSSL command-line interface to generate a 2048-bit RSA private
key:</p></p>
<p><pre class="prettyprint"><code class="lang-sh">openssl genrsa -out ryans-key.pem 2048
</code></pre></p>
<p><p>With TLS/SSL, all servers (and some clients) must have a <em>certificate</em>.
Certificates are <em>public keys</em> that correspond to a private key, and that are
digitally signed either by a Certificate Authority or by the owner of the
private key (such certificates are referred to as &quot;self-signed&quot;). The first
step to obtaining a certificate is to create a <em>Certificate Signing Request</em>
(CSR) file.</p></p>
<p><p>The OpenSSL command-line interface can be used to generate a CSR for a private
key:</p></p>
<p><pre class="prettyprint"><code class="lang-sh">openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem
</code></pre></p>
<p><p>Once the CSR file is generated, it can either be sent to a Certificate
Authority for signing or used to generate a self-signed certificate.</p></p>
<p><p>Creating a self-signed certificate using the OpenSSL command-line interface
is illustrated in the example below:</p></p>
<p><pre class="prettyprint"><code class="lang-sh">openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem
</code></pre></p>
<p><p>Once the certificate is generated, it can be used to generate a <code>.pfx</code> or
<code>.p12</code> file:</p></p>
<p><pre class="prettyprint"><code class="lang-sh">openssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem \
      -certfile ca-cert.pem -out ryans.pfx
</code></pre></p>
<p><p>Where:</p></p>
<ul>
<li><code>in</code>: is the signed certificate</li>
<li><code>inkey</code>: is the associated private key</li>
<li><code>certfile</code>: is a concatenation of all Certificate Authority (CA) certs into
 a single file, e.g. <code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>
</ul>

       <div class="heading">
          <h3>
            <a name="misc_Perfect_Forward_Secrecy" id="misc_Perfect_Forward_Secrecy"></a>
            <div class="permalink"><a href="#misc_Perfect_Forward_Secrecy" class="permalink fas fa-link"></a></div>
            <p>Perfect Forward Secrecy</p>

          </h1>
        </div><section><p>The term &quot;<a href="https://en.wikipedia.org/wiki/Perfect_forward_secrecy">Forward Secrecy</a>&quot; or &quot;Perfect Forward Secrecy&quot; describes a feature of
key-agreement (i.e., key-exchange) methods. That is, the server and client keys
are used to negotiate new temporary keys that are used specifically and only for
the current communication session. Practically, this means that even if the
server&#39;s private key is compromised, communication can only be decrypted by
eavesdroppers if the attacker manages to obtain the key-pair specifically
generated for the session.</p>
<p>Perfect Forward Secrecy is achieved by randomly generating a key pair for
key-agreement on every TLS/SSL handshake (in contrast to using the same key for
all sessions). Methods implementing this technique are called &quot;ephemeral&quot;.</p>
<p>Currently two methods are commonly used to achieve Perfect Forward Secrecy (note
the character &quot;E&quot; appended to the traditional abbreviations):</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">DHE</a> - An ephemeral version of the Diffie Hellman key-agreement protocol.</li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman">ECDHE</a> - An ephemeral version of the Elliptic Curve Diffie Hellman
key-agreement protocol.</li>
</ul>
<p>Ephemeral methods may have some performance drawbacks, because key generation
is expensive.</p>
<p>To use Perfect Forward Secrecy using <code>DHE</code> with the <code>tls</code> module, it is required
to generate Diffie-Hellman parameters and specify them with the <code>dhparam</code>
option to <a href="#tls_tls_createsecurecontext_options"><code>tls.createSecureContext()</code></a>. The following illustrates the use of
the OpenSSL command-line interface to generate such parameters:</p>
<pre class="prettyprint"><code class="lang-sh">openssl dhparam -outform PEM -out dhparam.pem 2048
</code></pre>
<p>If using Perfect Forward Secrecy using <code>ECDHE</code>, Diffie-Hellman parameters are
not required and a default ECDHE curve will be used. The <code>ecdhCurve</code> property
can be used when creating a TLS Server to specify the list of names of supported
curves to use, see <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a> for more info.</p>
</section>
       <div class="heading">
          <h3>
            <a name="misc_ALPN__NPN__and_SNI" id="misc_ALPN__NPN__and_SNI"></a>
            <div class="permalink"><a href="#misc_ALPN__NPN__and_SNI" class="permalink fas fa-link"></a></div>
            <p>ALPN, NPN, and SNI</p>

          </h1>
        </div><section><p>ALPN (Application-Layer Protocol Negotiation Extension), NPN (Next
Protocol Negotiation) and, SNI (Server Name Indication) are TLS
handshake extensions:</p>
<ul>
<li>ALPN/NPN - Allows the use of one TLS server for multiple protocols (HTTP,
SPDY, HTTP/2)</li>
<li>SNI - Allows the use of one TLS server for multiple hostnames with different
SSL certificates.</li>
</ul>
<p><em>Note</em>: Use of ALPN is recommended over NPN. The NPN extension has never been
formally defined or documented and generally not recommended for use.</p>
</section>
       <div class="heading">
          <h3>
            <a name="misc_Client_initiated_renegotiation_attack_mitigation" id="misc_Client_initiated_renegotiation_attack_mitigation"></a>
            <div class="permalink"><a href="#misc_Client_initiated_renegotiation_attack_mitigation" class="permalink fas fa-link"></a></div>
            <p>Client-initiated renegotiation attack mitigation</p>

          </h1>
        </div><section><p>The TLS protocol allows clients to renegotiate certain aspects of the TLS
session. Unfortunately, session renegotiation requires a disproportionate amount
of server-side resources, making it a potential vector for denial-of-service
attacks.</p>
<p>To mitigate the risk, renegotiation is limited to three times every ten minutes.
An <code>&#39;error&#39;</code> event is emitted on the <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> instance when this
threshold is exceeded. The limits are configurable:</p>
<ul>
<li><code>tls.CLIENT_RENEG_LIMIT</code> {number} Specifies the number of renegotiation
requests. Defaults to <code>3</code>.</li>
<li><code>tls.CLIENT_RENEG_WINDOW</code> {number} Specifies the time renegotiation window
in seconds. Defaults to <code>600</code> (10 minutes).</li>
</ul>
<p><em>Note</em>: The default renegotiation limits should not be modified without a full
understanding of the implications and risks.</p>
<p>To test the renegotiation limits on a server, connect to it using the OpenSSL
command-line client (<code>openssl s_client -connect address:port</code>) then input
<code>R&lt;CR&gt;</code> (i.e., the letter <code>R</code> followed by a carriage return) multiple times.</p>
</section></section>
       <div class="heading">
          <h2>
            <a name="module_modifying_the_default_tls_cipher_suite" id="module_modifying_the_default_tls_cipher_suite"></a>
            <div class="permalink"><a href="#module_modifying_the_default_tls_cipher_suite" class="permalink fas fa-link"></a></div>
            <p>Modifying the Default TLS Cipher suite</p>

          </h1>
        </div><section><p>Node.js is built with a default suite of enabled and disabled TLS ciphers.
Currently, the default cipher suite is:</p>
<pre class="prettyprint"><code class="lang-txt">ECDHE-RSA-AES128-GCM-SHA256:
ECDHE-ECDSA-AES128-GCM-SHA256:
ECDHE-RSA-AES256-GCM-SHA384:
ECDHE-ECDSA-AES256-GCM-SHA384:
DHE-RSA-AES128-GCM-SHA256:
ECDHE-RSA-AES128-SHA256:
DHE-RSA-AES128-SHA256:
ECDHE-RSA-AES256-SHA384:
DHE-RSA-AES256-SHA384:
ECDHE-RSA-AES256-SHA256:
DHE-RSA-AES256-SHA256:
HIGH:
!aNULL:
!eNULL:
!EXPORT:
!DES:
!RC4:
!MD5:
!PSK:
!SRP:
!CAMELLIA
</code></pre>
<p>This default can be replaced entirely using the <code>--tls-cipher-list</code> command
line switch. For instance, the following makes
<code>ECDHE-RSA-AES128-GCM-SHA256:!RC4</code> the default TLS cipher suite:</p>
<pre class="prettyprint"><code class="lang-sh">node --tls-cipher-list=&quot;ECDHE-RSA-AES128-GCM-SHA256:!RC4&quot;
</code></pre>
<p>The default can also be replaced on a per client or server basis using the
<code>ciphers</code> option from <a href="#tls_tls_createsecurecontext_options"><code>tls.createSecureContext()</code></a>, which is also available
in <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a>, <a href="#tls_tls_connect_options_callback"><code>tls.connect()</code></a>, and when creating new
<a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a>s.</p>
<p>Consult <a href="https://www.openssl.org/docs/man1.0.2/apps/ciphers.html#CIPHER-LIST-FORMAT">OpenSSL cipher list format documentation</a> for details on the format.</p>
<p><em>Note</em>: The default cipher suite included within Node.js has been carefully
selected to reflect current security best practices and risk mitigation.
Changing the default cipher suite can have a significant impact on the security
of an application. The <code>--tls-cipher-list</code> switch and <code>ciphers</code> option should by
used only if absolutely necessary.</p>
<p>The default cipher suite prefers GCM ciphers for <a href="https://www.chromium.org/Home/chromium-security/education/tls#TOC-Cipher-Suites">Chrome&#39;s &#39;modern
cryptography&#39; setting</a> and also prefers ECDHE and DHE ciphers for Perfect
Forward Secrecy, while offering <em>some</em> backward compatibility.</p>
<p>128 bit AES is preferred over 192 and 256 bit AES in light of <a href="https://www.schneier.com/blog/archives/2009/07/another_new_aes.html">specific
attacks affecting larger AES key sizes</a>.</p>
<p>Old clients that rely on insecure and deprecated RC4 or DES-based ciphers
(like Internet Explorer 6) cannot complete the handshaking process with
the default configuration. If these clients <em>must</em> be supported, the
<a href="https://wiki.mozilla.org/Security/Server_Side_TLS">TLS recommendations</a> may offer a compatible cipher suite. For more details
on the format, see the <a href="https://www.openssl.org/docs/man1.0.2/apps/ciphers.html#CIPHER-LIST-FORMAT">OpenSSL cipher list format documentation</a>.</p>
</section>
       <div class="heading">
          <h2>
            <a name="module_deprecated_apis_1" id="module_deprecated_apis_1"></a>
            <div class="permalink"><a href="#module_deprecated_apis_1" class="permalink fas fa-link"></a></div>
            <p>Deprecated APIs</p>

          </h1>
        </div><section>
       <div class="heading">
          <h3>
            <a name="class_CryptoStream" id="class_CryptoStream"></a>
            <div class="permalink"><a href="#class_CryptoStream" class="permalink fas fa-link"></a></div>
            <p>Class: CryptoStream</p>

          </h1>
        </div><section><p>The <code>tls.CryptoStream</code> class represents a stream of encrypted data. This class
has been deprecated and should no longer be used.</p>
<section>
       <div class="heading">
          <h5>
            <a name="property_bytesWritten_2" id="property_bytesWritten_2"></a>
            <div class="permalink"><a href="#property_bytesWritten_2" class="permalink fas fa-link"></a></div>
            <p>cryptoStream.bytesWritten</p>

          </h1>
        </div><section><p>The <code>cryptoStream.bytesWritten</code> property returns the total number of bytes
written to the underlying socket <em>including</em> the bytes required for the
implementation of the TLS protocol.</p>
</section></section></section>
       <div class="heading">
          <h3>
            <a name="class_SecurePair" id="class_SecurePair"></a>
            <div class="permalink"><a href="#class_SecurePair" class="permalink fas fa-link"></a></div>
            <p>Class: SecurePair</p>

          </h1>
        </div><section><p>Returned by <a href="#tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options"><code>tls.createSecurePair()</code></a>.</p>
</section>
       <div class="heading">
          <h3>
            <a name="method_createSecurePair_1" id="method_createSecurePair_1"></a>
            <div class="permalink"><a href="#method_createSecurePair_1" class="permalink fas fa-link"></a></div>
            <p>tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])</p>

          </h1>
        </div><section><p><p>Creates a new secure pair object with two streams, one of which reads and writes
the encrypted data and the other of which reads and writes the cleartext data.
Generally, the encrypted stream is piped to/from an incoming encrypted data
stream and the cleartext one is used as a replacement for the initial encrypted
stream.</p></p>
<p><p><code>tls.createSecurePair()</code> returns a <code>tls.SecurePair</code> object with <code>cleartext</code> and
<code>encrypted</code> stream properties.</p></p>
<p><p><em>Note</em>: <code>cleartext</code> has the same API as <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a>.</p></p>
<p><p><em>Note</em>: The <code>tls.createSecurePair()</code> method is now deprecated in favor of
<code>tls.TLSSocket()</code>. For example, the code:</p></p>
<p><pre class="prettyprint"><code class="lang-js">pair = tls.createSecurePair(/<em> ... </em>/);
pair.encrypted.pipe(socket);
socket.pipe(pair.encrypted);
</code></pre></p>
<p><p>can be replaced by:</p></p>
<p><pre class="prettyprint"><code class="lang-js">secure_socket = tls.TLSSocket(socket, options);
</code></pre></p>
<p><p>where <code>secure_socket</code> has the same API as <code>pair.cleartext</code>.</p>
<!-- [end-include:tls.md] -->
<!-- [start-include:tracing.md] --></p>
</section></section>
       <div class="heading">
          <h2>
            <a name="class_tls_Server" id="class_tls_Server"></a>
            <div class="permalink"><a href="#class_tls_Server" class="permalink fas fa-link"></a></div>
            <p>Class: tls.Server</p>

          </h1>
        </div><section><p>The <code>tls.Server</code> class is a subclass of <code>net.Server</code> that accepts encrypted
connections using TLS or SSL.</p>
<section>
       <div class="heading">
          <h4>
            <a name="property_connections_2" id="property_connections_2"></a>
            <div class="permalink"><a href="#property_connections_2" class="permalink fas fa-link"></a></div>
            <p>server.connections</p>

          </h1>
        </div><section><p>Returns the current number of concurrent connections on the server.</p>
</section></section><section>
       <div class="heading">
          <h4>
            <a name="method_addContext" id="method_addContext"></a>
            <div class="permalink"><a href="#method_addContext" class="permalink fas fa-link"></a></div>
            <p>server.addContext(hostname, context)</p>

          </h1>
        </div><section><p>The <code>server.addContext()</code> method adds a secure context that will be used if
the client request&#39;s SNI hostname matches the supplied <code>hostname</code> (or wildcard).</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_address_2" id="method_address_2"></a>
            <div class="permalink"><a href="#method_address_2" class="permalink fas fa-link"></a></div>
            <p>server.address()</p>

          </h1>
        </div><section><p>Returns the bound address, the address family name, and port of the
server as reported by the operating system.  See <a href="net.html#net_server_address"><code>net.Server.address()</code></a> for
more information.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_close_10" id="method_close_10"></a>
            <div class="permalink"><a href="#method_close_10" class="permalink fas fa-link"></a></div>
            <p>server.close([callback])</p>

          </h1>
        </div><section><p>The <code>server.close()</code> method stops the server from accepting new connections.</p>
<p>This function operates asynchronously. The <code>&#39;close&#39;</code> event will be emitted
when the server has no more open connections.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_getTicketKeys" id="method_getTicketKeys"></a>
            <div class="permalink"><a href="#method_getTicketKeys" class="permalink fas fa-link"></a></div>
            <p>server.getTicketKeys()</p>

          </h1>
        </div><section><p>Returns a <code>Buffer</code> instance holding the keys currently used for
encryption/decryption of the <a href="https://www.ietf.org/rfc/rfc5077.txt">TLS Session Tickets</a></p>
</section>
       <div class="heading">
          <h4>
            <a name="method_listen_7" id="method_listen_7"></a>
            <div class="permalink"><a href="#method_listen_7" class="permalink fas fa-link"></a></div>
            <p>server.listen()</p>

          </h1>
        </div><section><p>Starts the server listening for encrypted connections.
This method is identical to <a href="net.html#net_server_listen"><code>server.listen()</code></a> from <a href="net.html#net_class_net_server"><code>net.Server</code></a>.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_setTicketKeys" id="method_setTicketKeys"></a>
            <div class="permalink"><a href="#method_setTicketKeys" class="permalink fas fa-link"></a></div>
            <p>server.setTicketKeys(keys)</p>

          </h1>
        </div><section><p>Updates the keys for encryption/decryption of the <a href="https://www.ietf.org/rfc/rfc5077.txt">TLS Session Tickets</a>.</p>
<p><em>Note</em>: The key&#39;s <code>Buffer</code> should be 48 bytes long. See <code>ticketKeys</code> option in
<a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a> for
more information on how it is used.</p>
<p><em>Note</em>: Changes to the ticket keys are effective only for future server
connections. Existing or currently pending server connections will use the
previous keys.</p>
</section></section></section>
       <div class="heading">
          <h2>
            <a name="class_tls_TLSSocket" id="class_tls_TLSSocket"></a>
            <div class="permalink"><a href="#class_tls_TLSSocket" class="permalink fas fa-link"></a></div>
            <p>Class: tls.TLSSocket</p>

          </h1>
        </div><section><p>The <code>tls.TLSSocket</code> is a subclass of <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> that performs transparent
encryption of written data and all required TLS negotiation.</p>
<p>Instances of <code>tls.TLSSocket</code> implement the duplex <a href="stream.html#stream_stream">Stream</a> interface.</p>
<p><em>Note</em>: Methods that return TLS connection metadata (e.g.
<a href="#tls_tlssocket_getpeercertificate_detailed"><code>tls.TLSSocket.getPeerCertificate()</code></a> will only return data while the
connection is open.</p>
<section>
       <div class="heading">
          <h4>
            <a name="property_authorizationError" id="property_authorizationError"></a>
            <div class="permalink"><a href="#property_authorizationError" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.authorizationError</p>

          </h1>
        </div><section><p>Returns the reason why the peer&#39;s certificate was not been verified. This
property is set only when <code>tlsSocket.authorized === false</code>.</p>
</section>
       <div class="heading">
          <h4>
            <a name="property_authorized" id="property_authorized"></a>
            <div class="permalink"><a href="#property_authorized" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.authorized</p>

          </h1>
        </div><section><p>Returns <code>true</code> if the peer certificate was signed by one of the CAs specified
when creating the <code>tls.TLSSocket</code> instance, otherwise <code>false</code>.</p>
</section>
       <div class="heading">
          <h4>
            <a name="property_encrypted_1" id="property_encrypted_1"></a>
            <div class="permalink"><a href="#property_encrypted_1" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.encrypted</p>

          </h1>
        </div><section><p>Always returns <code>true</code>. This may be used to distinguish TLS sockets from regular
<code>net.Socket</code> instances.</p>
</section>
       <div class="heading">
          <h4>
            <a name="property_localAddress_1" id="property_localAddress_1"></a>
            <div class="permalink"><a href="#property_localAddress_1" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.localAddress</p>

          </h1>
        </div><section><p>Returns the string representation of the local IP address.</p>
</section>
       <div class="heading">
          <h4>
            <a name="property_localPort_1" id="property_localPort_1"></a>
            <div class="permalink"><a href="#property_localPort_1" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.localPort</p>

          </h1>
        </div><section><p>Returns the numeric representation of the local port.</p>
</section>
       <div class="heading">
          <h4>
            <a name="property_remoteAddress_1" id="property_remoteAddress_1"></a>
            <div class="permalink"><a href="#property_remoteAddress_1" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.remoteAddress</p>

          </h1>
        </div><section><p>Returns the string representation of the remote IP address. For example,
<code>&#39;74.125.127.100&#39;</code> or <code>&#39;2001:4860:a005::68&#39;</code>.</p>
</section>
       <div class="heading">
          <h4>
            <a name="property_remoteFamily_1" id="property_remoteFamily_1"></a>
            <div class="permalink"><a href="#property_remoteFamily_1" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.remoteFamily</p>

          </h1>
        </div><section><p>Returns the string representation of the remote IP family. <code>&#39;IPv4&#39;</code> or <code>&#39;IPv6&#39;</code>.</p>
</section>
       <div class="heading">
          <h4>
            <a name="property_remotePort_1" id="property_remotePort_1"></a>
            <div class="permalink"><a href="#property_remotePort_1" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.remotePort</p>

          </h1>
        </div><section><p>Returns the numeric representation of the remote port. For example, <code>443</code>.</p>
</section></section><section>
       <div class="heading">
          <h4>
            <a name="method_TLSSocket" id="method_TLSSocket"></a>
            <div class="permalink"><a href="#method_TLSSocket" class="permalink fas fa-link"></a></div>
            <p>new tls.TLSSocket(socket[, options])</p>

          </h1>
        </div><section><p>Construct a new <code>tls.TLSSocket</code> object from an existing TCP socket.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_address_3" id="method_address_3"></a>
            <div class="permalink"><a href="#method_address_3" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.address()</p>

          </h1>
        </div><section><p>Returns the bound address, the address family name, and port of the
underlying socket as reported by the operating system. Returns an
object with three properties, e.g.
<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code></p>
</section>
       <div class="heading">
          <h4>
            <a name="method_disableRenegotiation" id="method_disableRenegotiation"></a>
            <div class="permalink"><a href="#method_disableRenegotiation" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.disableRenegotiation()</p>

          </h1>
        </div><section><p>Disables TLS renegotiation for this <code>TLSSocket</code> instance. Once called, attempts
to renegotiate will trigger an <code>&#39;error&#39;</code> event on the <code>TLSSocket</code>.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_getCipher" id="method_getCipher"></a>
            <div class="permalink"><a href="#method_getCipher" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.getCipher()</p>

          </h1>
        </div><section><p>Returns an object representing the cipher name. The <code>version</code> key is a legacy
field which always contains the value <code>&#39;TLSv1/SSLv3&#39;</code>.</p>
<p>For example: <code>{ name: &#39;AES256-SHA&#39;, version: &#39;TLSv1/SSLv3&#39; }</code></p>
<p>See <code>SSL_CIPHER_get_name()</code> in
<a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_CIPHER_get_name.html">https://www.openssl.org/docs/man1.0.2/ssl/SSL_CIPHER_get_name.html</a> for more
information.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_getEphemeralKeyInfo" id="method_getEphemeralKeyInfo"></a>
            <div class="permalink"><a href="#method_getEphemeralKeyInfo" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.getEphemeralKeyInfo()</p>

          </h1>
        </div><section><p>Returns an object representing the type, name, and size of parameter of
an ephemeral key exchange in <a href="#tls_perfect_forward_secrecy">Perfect Forward Secrecy</a> on a client
connection. It returns an empty object when the key exchange is not
ephemeral. As this is only supported on a client socket; <code>null</code> is returned
if called on a server socket. The supported types are <code>&#39;DH&#39;</code> and <code>&#39;ECDH&#39;</code>. The
<code>name</code> property is available only when type is &#39;ECDH&#39;.</p>
<p>For Example: <code>{ type: &#39;ECDH&#39;, name: &#39;prime256v1&#39;, size: 256 }</code></p>
</section>
       <div class="heading">
          <h4>
            <a name="method_getPeerCertificate" id="method_getPeerCertificate"></a>
            <div class="permalink"><a href="#method_getPeerCertificate" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.getPeerCertificate([detailed])</p>

          </h1>
        </div><section><p>Returns an object representing the peer&#39;s certificate. The returned object has
some properties corresponding to the fields of the certificate.</p>
<p>If the full certificate chain was requested, each certificate will include a
<code>issuerCertificate</code> property containing an object representing its issuer&#39;s
certificate.</p>
<p>For example:</p>
<pre class="prettyprint"><code class="lang-text">{ subject:
   { C: &#39;UK&#39;,
     ST: &#39;Acknack Ltd&#39;,
     L: &#39;Rhys Jones&#39;,
     O: &#39;node.js&#39;,
     OU: &#39;Test TLS Certificate&#39;,
     CN: &#39;localhost&#39; },
  issuer:
   { C: &#39;UK&#39;,
     ST: &#39;Acknack Ltd&#39;,
     L: &#39;Rhys Jones&#39;,
     O: &#39;node.js&#39;,
     OU: &#39;Test TLS Certificate&#39;,
     CN: &#39;localhost&#39; },
  issuerCertificate:
   { ... another certificate, possibly with a .issuerCertificate ... },
  raw: &lt; RAW DER buffer &gt;,
  valid_from: &#39;Nov 11 09:52:22 2009 GMT&#39;,
  valid_to: &#39;Nov  6 09:52:22 2029 GMT&#39;,
  fingerprint: &#39;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&#39;,
  serialNumber: &#39;B9B0D332A1AA5635&#39; }
</code></pre>
<p>If the peer does not provide a certificate, an empty object will be returned.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_getProtocol" id="method_getProtocol"></a>
            <div class="permalink"><a href="#method_getProtocol" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.getProtocol()</p>

          </h1>
        </div><section><p>Returns a string containing the negotiated SSL/TLS protocol version of the
current connection. The value <code>&#39;unknown&#39;</code> will be returned for connected
sockets that have not completed the handshaking process. The value <code>null</code> will
be returned for server sockets or disconnected client sockets.</p>
<p>Example responses include:</p>
<ul>
<li><code>SSLv3</code></li>
<li><code>TLSv1</code></li>
<li><code>TLSv1.1</code></li>
<li><code>TLSv1.2</code></li>
<li><code>unknown</code></li>
</ul>
<p>See <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html">https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html</a> for more
information.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_getSession" id="method_getSession"></a>
            <div class="permalink"><a href="#method_getSession" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.getSession()</p>

          </h1>
        </div><section><p>Returns the ASN.1 encoded TLS session or <code>undefined</code> if no session was
negotiated. Can be used to speed up handshake establishment when reconnecting
to the server.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_getTLSTicket" id="method_getTLSTicket"></a>
            <div class="permalink"><a href="#method_getTLSTicket" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.getTLSTicket()</p>

          </h1>
        </div><section><p>Returns the TLS session ticket or <code>undefined</code> if no session was negotiated.</p>
<p><em>Note</em>: This only works with client TLS sockets. Useful only for debugging,
for session reuse provide <code>session</code> option to <a href="#tls_tls_connect_options_callback"><code>tls.connect()</code></a>.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_renegotiate" id="method_renegotiate"></a>
            <div class="permalink"><a href="#method_renegotiate" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.renegotiate(options, callback)</p>

          </h1>
        </div><section><p>The <code>tlsSocket.renegotiate()</code> method initiates a TLS renegotiation process.
Upon completion, the <code>callback</code> function will be passed a single argument
that is either an <code>Error</code> (if the request failed) or <code>null</code>.</p>
<p><em>Note</em>: This method can be used to request a peer&#39;s certificate after the
secure connection has been established.</p>
<p><em>Note</em>: When running as the server, the socket will be destroyed with an error
after <code>handshakeTimeout</code> timeout.</p>
</section>
       <div class="heading">
          <h4>
            <a name="method_setMaxSendFragment" id="method_setMaxSendFragment"></a>
            <div class="permalink"><a href="#method_setMaxSendFragment" class="permalink fas fa-link"></a></div>
            <p>tlsSocket.setMaxSendFragment(size)</p>

          </h1>
        </div><section><p>The <code>tlsSocket.setMaxSendFragment()</code> method sets the maximum TLS fragment size.
Returns <code>true</code> if setting the limit succeeded; <code>false</code> otherwise.</p>
<p>Smaller fragment sizes decrease the buffering latency on the client: larger
fragments are buffered by the TLS layer until the entire fragment is received
and its integrity is verified; large fragments can span multiple roundtrips
and their processing can be delayed due to packet loss or reordering. However,
smaller fragments add extra TLS framing bytes and CPU overhead, which may
decrease overall server throughput.</p>
</section></section></section>
       <div class="heading">
          <h2>
            <a name="property_DEFAULT_ECDH_CURVE" id="property_DEFAULT_ECDH_CURVE"></a>
            <div class="permalink"><a href="#property_DEFAULT_ECDH_CURVE" class="permalink fas fa-link"></a></div>
            <p>tls.DEFAULT_ECDH_CURVE</p>

          </h1>
        </div><section><p>The default curve name to use for ECDH key agreement in a tls server. The
default value is <code>&#39;prime256v1&#39;</code> (NIST P-256). Consult <a href="https://www.rfc-editor.org/rfc/rfc4492.txt">RFC 4492</a> and
<a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">FIPS.186-4</a> for more details.</p>
</section>
       <div class="heading">
          <h2>
            <a name="method_checkServerIdentity" id="method_checkServerIdentity"></a>
            <div class="permalink"><a href="#method_checkServerIdentity" class="permalink fas fa-link"></a></div>
            <p>tls.checkServerIdentity(host, cert)</p>

          </h1>
        </div><section><p><p>Verifies the certificate <code>cert</code> is issued to host <code>host</code>.</p></p>
<p><p>Returns {Error} object, populating it with the reason, host, and cert on
failure. On success, returns {undefined}.</p></p>
<p><p><em>Note</em>: This function can be overwritten by providing alternative function
as part of the <code>options.checkServerIdentity</code> option passed to <code>tls.connect()</code>.
The overwriting function can call <code>tls.checkServerIdentity()</code> of course, to augment
the checks done with additional verification.</p></p>
<p><p><em>Note</em>: This function is only called if the certificate passed all other checks, such as
being issued by trusted CA (<code>options.ca</code>).</p></p>
<p><p>The cert object contains the parsed certificate and will have a structure similar to:</p></p>
<pre class="prettyprint"><code class="lang-text">{ subject:
   { OU: [ &#39;Domain Control Validated&#39;, &#39;PositiveSSL Wildcard&#39; ],
     CN: &#39;*.nodejs.org&#39; },
  issuer:
   { C: &#39;GB&#39;,
     ST: &#39;Greater Manchester&#39;,
     L: &#39;Salford&#39;,
     O: &#39;COMODO CA Limited&#39;,
     CN: &#39;COMODO RSA Domain Validation Secure Server CA&#39; },
  subjectaltname: &#39;DNS:*.nodejs.org, DNS:nodejs.org&#39;,
  infoAccess:
   { &#39;CA Issuers - URI&#39;:
      [ &#39;http://crt.comodoca.com/COMODORSADomainValidationSecureServerCA.crt&#39; ],
     &#39;OCSP - URI&#39;: [ &#39;http://ocsp.comodoca.com&#39; ] },
  modulus: &#39;B56CE45CB740B09A13F64AC543B712FF9EE8E4C284B542A1708A27E82A8D151CA178153E12E6DDA15BF70FFD96CB8A88618641BDFCCA03527E665B70D779C8A349A6F88FD4EF6557180BD4C98192872BCFE3AF56E863C09DDD8BC1EC58DF9D94F914F0369102B2870BECFA1348A0838C9C49BD1C20124B442477572347047506B1FCD658A80D0C44BCC16BC5C5496CFE6E4A8428EF654CD3D8972BF6E5BFAD59C93006830B5EB1056BBB38B53D1464FA6E02BFDF2FF66CD949486F0775EC43034EC2602AEFBF1703AD221DAA2A88353C3B6A688EFE8387811F645CEED7B3FE46E1F8B9F59FAD028F349B9BC14211D5830994D055EEA3D547911E07A0ADDEB8A82B9188E58720D95CD478EEC9AF1F17BE8141BE80906F1A339445A7EB5B285F68039B0F294598A7D1C0005FC22B5271B0752F58CCDEF8C8FD856FB7AE21C80B8A2CE983AE94046E53EDE4CB89F42502D31B5360771C01C80155918637490550E3F555E2EE75CC8C636DDE3633CFEDD62E91BF0F7688273694EEEBA20C2FC9F14A2A435517BC1D7373922463409AB603295CEB0BB53787A334C9CA3CA8B30005C5A62FC0715083462E00719A8FA3ED0A9828C3871360A73F8B04A4FC1E71302844E9BB9940B77E745C9D91F226D71AFCAD4B113AAF68D92B24DDB4A2136B55A1CD1ADF39605B63CB639038ED0F4C987689866743A68769CC55847E4A06D6E2E3F1&#39;,
  exponent: &#39;0x10001&#39;,
  valid_from: &#39;Aug 14 00:00:00 2017 GMT&#39;,
  valid_to: &#39;Nov 20 23:59:59 2019 GMT&#39;,
  fingerprint: &#39;01:02:59:D9:C3:D2:0D:08:F7:82:4E:44:A4:B4:53:C5:E2:3A:87:4D&#39;,
  ext_key_usage: [ &#39;1.3.6.1.5.5.7.3.1&#39;, &#39;1.3.6.1.5.5.7.3.2&#39; ],
  serialNumber: &#39;66593D57F20CBC573E433381B5FEC280&#39;,
  raw: &lt;Buffer ....&gt; }
</code></pre>
</section>
       <div class="heading">
          <h2>
            <a name="method_connect_10" id="method_connect_10"></a>
            <div class="permalink"><a href="#method_connect_10" class="permalink fas fa-link"></a></div>
            <p>tls.connect(options[, callback])</p>

          </h1>
        </div><section><p><p>The <code>callback</code> function, if specified, will be added as a listener for the
<a href="#tls_event_secureconnect"><code>&#39;secureConnect&#39;</code></a> event.</p></p>
<p><p><code>tls.connect()</code> returns a <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> object.</p></p>
<p><p>The following implements a simple &quot;echo server&quot; example:</p></p>
<pre class="prettyprint"><code class="lang-js">const tls = require(&#39;tls&#39;);
const fs = require(&#39;fs&#39;);

const options = {
  // Necessary only if using the client certificate authentication
  key: fs.readFileSync(&#39;client-key.pem&#39;),
  cert: fs.readFileSync(&#39;client-cert.pem&#39;),

  // Necessary only if the server uses the self-signed certificate
  ca: [ fs.readFileSync(&#39;server-cert.pem&#39;) ]
};

const socket = tls.connect(8000, options, () =&gt; {
  console.log(&#39;client connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&#39;utf8&#39;);
socket.on(&#39;data&#39;, (data) =&gt; {
  console.log(data);
});
socket.on(&#39;end&#39;, () =&gt; {
  server.close();
});
</code></pre>
<p>Or</p>
<pre class="prettyprint"><code class="lang-js">const tls = require(&#39;tls&#39;);
const fs = require(&#39;fs&#39;);

const options = {
  pfx: fs.readFileSync(&#39;client.pfx&#39;)
};

const socket = tls.connect(8000, options, () =&gt; {
  console.log(&#39;client connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&#39;utf8&#39;);
socket.on(&#39;data&#39;, (data) =&gt; {
  console.log(data);
});
socket.on(&#39;end&#39;, () =&gt; {
  server.close();
});
</code></pre>
</section>
       <div class="heading">
          <h2>
            <a name="method_connect_11" id="method_connect_11"></a>
            <div class="permalink"><a href="#method_connect_11" class="permalink fas fa-link"></a></div>
            <p>tls.connect(path[, options][, callback])</p>

          </h1>
        </div><section><p>Same as <a href="#tls_tls_connect_options_callback"><code>tls.connect()</code></a> except that <code>path</code> can be provided
as an argument instead of an option.</p>
<p><em>Note</em>: A path option, if specified, will take precedence over the path
argument.</p>
</section>
       <div class="heading">
          <h2>
            <a name="method_connect_12" id="method_connect_12"></a>
            <div class="permalink"><a href="#method_connect_12" class="permalink fas fa-link"></a></div>
            <p>tls.connect(port[, host][, options][, callback])</p>

          </h1>
        </div><section><p>Same as <a href="#tls_tls_connect_options_callback"><code>tls.connect()</code></a> except that <code>port</code> and <code>host</code> can be provided
as arguments instead of options.</p>
<p><em>Note</em>: A port or host option, if specified, will take precedence over any
port or host argument.</p>
</section>
       <div class="heading">
          <h2>
            <a name="method_createSecureContext" id="method_createSecureContext"></a>
            <div class="permalink"><a href="#method_createSecureContext" class="permalink fas fa-link"></a></div>
            <p>tls.createSecureContext(options)</p>

          </h1>
        </div><section><p><em>Note</em>:</p>
<ul>
<li><p><a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a> sets the default value of the
<code>honorCipherOrder</code> option to <code>true</code>, other APIs that create secure contexts
leave it unset.</p>
</li>
<li><p><a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a> uses a 128 bit truncated SHA1 hash value
generated from <code>process.argv</code> as the default value of the <code>sessionIdContext</code>
option, other APIs that create secure contexts have no default value.</p>
</li>
</ul>
<p>The <code>tls.createSecureContext()</code> method creates a credentials object.</p>
<p>A key is <em>required</em> for ciphers that make use of certificates. Either <code>key</code> or
<code>pfx</code> can be used to provide it.</p>
<p>If the &#39;ca&#39; option is not given, then Node.js will use the default
publicly trusted list of CAs as given in
<a href="https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt">https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p>
</section>
       <div class="heading">
          <h2>
            <a name="method_createServer_4" id="method_createServer_4"></a>
            <div class="permalink"><a href="#method_createServer_4" class="permalink fas fa-link"></a></div>
            <p>tls.createServer([options][, secureConnectionListener])</p>

          </h1>
        </div><section><p><p>Creates a new <a href="#tls_class_tls_server">tls.Server</a>.  The <code>secureConnectionListener</code>, if provided, is
automatically set as a listener for the <a href="#tls_event_secureconnection"><code>&#39;secureConnection&#39;</code></a> event.</p></p>
<p><p><em>Note</em>: The <code>ticketKeys</code> options is automatically shared between <code>cluster</code>
module workers.</p></p>
<p><p>The following illustrates a simple echo server:</p></p>
<pre class="prettyprint"><code class="lang-js">const tls = require(&#39;tls&#39;);
const fs = require(&#39;fs&#39;);

const options = {
  key: fs.readFileSync(&#39;server-key.pem&#39;),
  cert: fs.readFileSync(&#39;server-cert.pem&#39;),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

  // This is necessary only if the client uses the self-signed certificate.
  ca: [ fs.readFileSync(&#39;client-cert.pem&#39;) ]
};

const server = tls.createServer(options, (socket) =&gt; {
  console.log(&#39;server connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  socket.write(&#39;welcome!\n&#39;);
  socket.setEncoding(&#39;utf8&#39;);
  socket.pipe(socket);
});
server.listen(8000, () =&gt; {
  console.log(&#39;server bound&#39;);
});
</code></pre>
<p>Or</p>
<pre class="prettyprint"><code class="lang-js">const tls = require(&#39;tls&#39;);
const fs = require(&#39;fs&#39;);

const options = {
  pfx: fs.readFileSync(&#39;server.pfx&#39;),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

};

const server = tls.createServer(options, (socket) =&gt; {
  console.log(&#39;server connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  socket.write(&#39;welcome!\n&#39;);
  socket.setEncoding(&#39;utf8&#39;);
  socket.pipe(socket);
});
server.listen(8000, () =&gt; {
  console.log(&#39;server bound&#39;);
});
</code></pre>
<p>This server can be tested by connecting to it using <code>openssl s_client</code>:</p>
<pre class="prettyprint"><code class="lang-sh">openssl s_client -connect 127.0.0.1:8000
</code></pre>
</section>
       <div class="heading">
          <h2>
            <a name="method_getCiphers_1" id="method_getCiphers_1"></a>
            <div class="permalink"><a href="#method_getCiphers_1" class="permalink fas fa-link"></a></div>
            <p>tls.getCiphers()</p>

          </h1>
        </div><section><p><p>Returns an array with the names of the supported SSL ciphers.</p></p>
<p><p>For example:</p></p>
<pre class="prettyprint"><code class="lang-js">console.log(tls.getCiphers()); // [&#39;AES128-SHA&#39;, &#39;AES256-SHA&#39;, ...]
</code></pre>
</section>

  <div class="footer">
    <p>Some footer text. Optional. Copyright &copy; whenever by your bidness.</p>
    <p>Dubbed by <img src="images/mixtape.png" title="Dubbed by mixtape." style="width:40px;position:relative;top:8px"></img> mixtape.</p>
  </div>

  </div>
  </body>
</html>